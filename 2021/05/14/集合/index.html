<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;mingren1314.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta name="description" content="集合什么是集合概念： 对象的容器，定义了对多个对象进项操作的的常用方法。可实现数组的功能。 和数组区别：  数组长度固定，集合长度不固定。 数组可以存储基本类型和引用类型，集合只能存储引用类型。  位置： java.util.*; Collection体系集合Collection父接口特点：代表一组任意类型的对象，无序、无下标、不能重复。 方法： 123456789boolean add(Obje">
<meta property="og:type" content="article">
<meta property="og:title" content="集合">
<meta property="og:url" content="https://mingren1314.github.io/2021/05/14/%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="集合什么是集合概念： 对象的容器，定义了对多个对象进项操作的的常用方法。可实现数组的功能。 和数组区别：  数组长度固定，集合长度不固定。 数组可以存储基本类型和引用类型，集合只能存储引用类型。  位置： java.util.*; Collection体系集合Collection父接口特点：代表一组任意类型的对象，无序、无下标、不能重复。 方法： 123456789boolean add(Obje">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic.downk.cc/item/5f9a62a01cd1bbb86bc58487.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f9a631c1cd1bbb86bc59ca6.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f9a680e1cd1bbb86bc681f6.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f9a6b371cd1bbb86bc74cda.png">
<meta property="article:published_time" content="2021-05-14T10:19:10.000Z">
<meta property="article:modified_time" content="2021-05-14T10:21:14.691Z">
<meta property="article:author" content="mingr">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.downk.cc/item/5f9a62a01cd1bbb86bc58487.png">


<link rel="canonical" href="https://mingren1314.github.io/2021/05/14/%E9%9B%86%E5%90%88/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;mingren1314.github.io&#x2F;2021&#x2F;05&#x2F;14&#x2F;%E9%9B%86%E5%90%88&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;05&#x2F;14&#x2F;集合&#x2F;&quot;,&quot;title&quot;:&quot;集合&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>集合 | Hexo</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E5%90%88"><span class="nav-number">1.1.</span> <span class="nav-text">什么是集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection%E4%BD%93%E7%B3%BB%E9%9B%86%E5%90%88"><span class="nav-number">1.2.</span> <span class="nav-text">Collection体系集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection%E7%88%B6%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.3.</span> <span class="nav-text">Collection父接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A81"><span class="nav-number">1.3.1.</span> <span class="nav-text">Collection接口的使用1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A82"><span class="nav-number">1.3.2.</span> <span class="nav-text">Collection接口的使用2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E7%94%9F%E7%B1%BB"><span class="nav-number">1.3.3.</span> <span class="nav-text">学生类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection%E5%AD%90%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.</span> <span class="nav-text">Collection子接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E9%9B%86%E5%90%88"><span class="nav-number">1.4.1.</span> <span class="nav-text">List集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A81"><span class="nav-number">1.4.2.</span> <span class="nav-text">List集合的使用1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A82"><span class="nav-number">1.4.3.</span> <span class="nav-text">List集合的使用2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList"><span class="nav-number">1.4.4.</span> <span class="nav-text">ArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.4.5.</span> <span class="nav-text">ArrayL源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector"><span class="nav-number">1.4.6.</span> <span class="nav-text">Vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList"><span class="nav-number">1.4.7.</span> <span class="nav-text">LinkedList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.4.8.</span> <span class="nav-text">LinkedList源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.9.</span> <span class="nav-text">ArrayList和LinkedList区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-number">1.5.1.</span> <span class="nav-text">泛型类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.5.2.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.5.3.</span> <span class="nav-text">泛型接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.4.</span> <span class="nav-text">泛型方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%A5%BD%E5%A4%84"><span class="nav-number">1.5.5.</span> <span class="nav-text">泛型好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88"><span class="nav-number">1.5.6.</span> <span class="nav-text">泛型集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set%E9%9B%86%E5%90%88"><span class="nav-number">1.6.</span> <span class="nav-text">set集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#set%E5%AD%90%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.6.1.</span> <span class="nav-text">set子接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">1.6.2.</span> <span class="nav-text">set实现类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet-%E9%87%8D%E7%82%B9"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">HashSet(重点)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeSet"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">TreeSet</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E9%9B%86%E5%90%88"><span class="nav-number">1.7.</span> <span class="nav-text">Map集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">1.7.1.</span> <span class="nav-text">Map实现类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E9%87%8D%E7%82%B9"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">HashMap(重点)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">HashMap源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">HashSet源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hashtable"><span class="nav-number">1.7.1.4.</span> <span class="nav-text">Hashtable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Properties"><span class="nav-number">1.7.1.5.</span> <span class="nav-text">Properties</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeMap"><span class="nav-number">1.7.1.6.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeSet%E6%BA%90%E7%A0%81"><span class="nav-number">1.7.1.7.</span> <span class="nav-text">TreeSet源码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">1.8.</span> <span class="nav-text">Collections工具类</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">mingr</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://mingren1314.github.io/2021/05/14/%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mingr">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          集合
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-05-14 18:19:10 / Modified: 18:21:14" itemprop="dateCreated datePublished" datetime="2021-05-14T18:19:10+08:00">2021-05-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h2><p>概念：</p>
<p>对象的容器，定义了对多个对象进项操作的的常用方法。可实现数组的功能。</p>
<p>和数组区别：</p>
<ol>
<li>数组长度固定，集合长度不固定。</li>
<li>数组可以存储基本类型和引用类型，集合只能存储引用类型。</li>
</ol>
<p>位置：</p>
<p>java.util.*;</p>
<h2 id="Collection体系集合"><a href="#Collection体系集合" class="headerlink" title="Collection体系集合"></a>Collection体系集合</h2><h2 id="Collection父接口"><a href="#Collection父接口" class="headerlink" title="Collection父接口"></a>Collection父接口</h2><p><strong>特点</strong>：代表一组任意类型的对象，无序、无下标、不能重复。</p>
<p><strong>方法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">boolean add(Object obj) //添加一个对象。</span><br><span class="line">boolean addAll(Collection c) //讲一个集合中的所有对象添加到此集合中。</span><br><span class="line">void clear() //清空此集合中的所有对象。</span><br><span class="line">boolean contains(Object o) //检查此集合中是否包含o对象。</span><br><span class="line">boolean equals(Object o) //比较此集合是否与指定对象相等。</span><br><span class="line">boolean isEmpty() //判断此集合是否为空。</span><br><span class="line">boolean remove(Object o) //在此集合中移除o对象。</span><br><span class="line">int size() //返回此集合中的元素个数。</span><br><span class="line">Object[] toArray() //将此集合转换成数组。</span><br></pre></td></tr></table></figure>

<h3 id="Collection接口的使用1"><a href="#Collection接口的使用1" class="headerlink" title="Collection接口的使用1"></a>Collection接口的使用1</h3><pre><code>@Test
    public void CollectionTest01()&#123;
        //创建集合 Collection是接口 不能实例化 通过子类实例化
        Collection collection=new ArrayList();
        //添加元素
        collection.add(&quot;苹果&quot;);
        collection.add(&quot;香蕉&quot;);
        collection.add(&quot;梨&quot;);
        System.out.println(&quot;元素个数为：&quot;+collection.size());
        System.out.println(collection);//其实调用的是collection.toString方法

        //删除元素
        //collection.remove(&quot;香蕉&quot;);//clear()是清空元素
        System.out.println(&quot;元素个数为：&quot;+collection.size());
        System.out.println(collection);

        //遍历元素(重点)
        //通过增强for遍历
        for(Object object:collection)&#123;
            System.out.println(object);//可以像下面测试2一样强转一下类型 也可以不用强转
        &#125;

        //通过迭代器遍历
        Iterator it=collection.iterator();
        while(it.hasNext())&#123;//hasNext()方法 下一位置有无元素 Boolean
            //可以像下面测试2一样强转一下类型 也可以不用强转
            System.out.println(it.next());//返回指的位置的元素
            //it.remove();//可以用迭代器删除元素  但是不可以 collection.remove()这样删除元素
        &#125;

        //判断有无元素
        System.out.println(collection.contains(&quot;香蕉&quot;));
        System.out.println(collection.contains(&quot;西瓜&quot;));

        //判断是否为空
        System.out.println(collection.isEmpty());
    &#125;
</code></pre>
<h3 id="Collection接口的使用2"><a href="#Collection接口的使用2" class="headerlink" title="Collection接口的使用2"></a>Collection接口的使用2</h3><pre><code>   @Test
    public void CollectionTest02()&#123;
        //创建集合
        Collection collection=new ArrayList();

        Student student1=new Student(&quot;张三&quot;,15);
        Student student2=new Student(&quot;李四&quot;,18);
        Student student3=new Student(&quot;王五&quot;,20);

        //添加数据
        collection.add(student1);
        collection.add(student2);
        collection.add(student3);
        System.out.println(&quot;集合数据个数为：&quot;+collection.size());
        System.out.println(collection.toString());

        //删除数据
        collection.remove(student1);
        System.out.println(&quot;集合数据个数为：&quot;+collection.size());
        System.out.println(collection.toString());

        //遍历集合
        //增强for
        for(Object object:collection)&#123;
            Student stu=(Student)object;
            System.out.println(stu);
        &#125;

        System.out.println(&quot;---------------&quot;);
        //迭代器 迭代过程不能使用collection的删除方法
        Iterator it=collection.iterator();
        while(it.hasNext())&#123;
            Student stu=(Student) it.next();
            System.out.println(stu);
        &#125;
    &#125;
</code></pre>
<h3 id="学生类"><a href="#学生类" class="headerlink" title="学生类"></a>学生类</h3><pre><code>public class Student &#123;
    String name;
    int age;

    public Student(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<h2 id="Collection子接口"><a href="#Collection子接口" class="headerlink" title="Collection子接口"></a>Collection子接口</h2><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><p><strong>特点</strong>：有序、有下标、元素可以重复。</p>
<p><strong>方法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void add(int index,Object o) //在index位置插入对象o</span><br><span class="line"></span><br><span class="line">boolean addAll(index,Collection c) //将一个集合中的元素添加到此集合中的index位置。</span><br><span class="line"></span><br><span class="line">Object get(int index) //返回集合中指定位置的元素。</span><br><span class="line"></span><br><span class="line">List subList(int fromIndex,int toIndex) //返回fromIndex和toIndex之间的集合元素。</span><br></pre></td></tr></table></figure>

<h3 id="List集合的使用1"><a href="#List集合的使用1" class="headerlink" title="List集合的使用1"></a>List集合的使用1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void ListTest01()&#123;</span><br><span class="line">    //创建集合</span><br><span class="line">    List list=new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    //添加数据</span><br><span class="line">    list.add(&quot;张三&quot;);</span><br><span class="line">    list.add(&quot;李四&quot;);</span><br><span class="line">    list.add(0,&quot;王五&quot;);</span><br><span class="line">    System.out.println(&quot;数据个数为：&quot;+list.size());</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    //删除数据</span><br><span class="line">    list.remove(&quot;张三&quot;);//等同于 list.remove(0);</span><br><span class="line"></span><br><span class="line">    //遍历数据</span><br><span class="line">    //普通for循环</span><br><span class="line">    for(int i=0;i&lt;list.size();i++)&#123;</span><br><span class="line">        System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //加强for</span><br><span class="line">    for(Object object:list)&#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //迭代器</span><br><span class="line">    Iterator it=list.iterator();</span><br><span class="line">    while(it.hasNext())&#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-----------------------&quot;);</span><br><span class="line">    //使用列表迭代器，listIterator可以双向遍历，添加、删除及修改元素</span><br><span class="line">    ListIterator listIterator=list.listIterator();</span><br><span class="line"></span><br><span class="line">    //从前向后遍历</span><br><span class="line">    while(listIterator.hasNext())&#123;</span><br><span class="line">        System.out.println(listIterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-----------------------&quot;);</span><br><span class="line">    //从后向前(此时指针指向末尾)</span><br><span class="line">    while(listIterator.hasPrevious())&#123;</span><br><span class="line">        System.out.println(listIterator.previous());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-----------------------&quot;);</span><br><span class="line">    //判断</span><br><span class="line">    System.out.println(list.isEmpty());</span><br><span class="line">    System.out.println(list.contains(&quot;王五&quot;));</span><br><span class="line">    //获取位置</span><br><span class="line">    System.out.println(list.indexOf(&quot;李四&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List集合的使用2"><a href="#List集合的使用2" class="headerlink" title="List集合的使用2"></a>List集合的使用2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void ListTest02()&#123;</span><br><span class="line">    //创建集合</span><br><span class="line">    List list=new ArrayList();</span><br><span class="line"></span><br><span class="line">    //添加数字 自动装箱 20这些数字不再是基本数据类型了 而变成了包装类</span><br><span class="line">    list.add(20);</span><br><span class="line">    list.add(30);</span><br><span class="line">    list.add(40);</span><br><span class="line">    list.add(50);</span><br><span class="line">    list.add(60);</span><br><span class="line">    System.out.println(&quot;元素个数为：&quot;+list.size());</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    //删除操作</span><br><span class="line">    //list.remove(20);  如果想删除20 它调用的是数组下标 会越界报错 所以可以用下面两种方法</span><br><span class="line">    list.remove((Object)20);//法1</span><br><span class="line">    list.remove(new Integer(20));//法2</span><br><span class="line">    System.out.println(&quot;元素个数为：&quot;+list.size());</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    List list2=list.subList(1,3);//包含1 不包含3 (含头不含尾)</span><br><span class="line">    System.out.println(list2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>数组结构实现，查询块、增删慢；</p>
<p>JDK1.2版本，运行效率快、线程不安全。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void ArrayListTest01()&#123;</span><br><span class="line">    ArrayList arrayList=new ArrayList();</span><br><span class="line">    Student s1=new Student(&quot;张三&quot;, 21);</span><br><span class="line">    Student s2=new Student(&quot;李四&quot;, 22);</span><br><span class="line">    Student s3=new Student(&quot;王五&quot;, 21);</span><br><span class="line">    arrayList.add(s1);</span><br><span class="line">    arrayList.add(s2);</span><br><span class="line">    arrayList.add(s3);</span><br><span class="line">    System.out.println(&quot;元素个数：&quot;+arrayList.size());</span><br><span class="line">    System.out.println(arrayList.toString());</span><br><span class="line">    //2.删除元素</span><br><span class="line">    arrayList.remove(s1);</span><br><span class="line">    System.out.println(&quot;元素个数：&quot;+arrayList.size());</span><br><span class="line">    System.out.println(arrayList.toString());</span><br><span class="line">    //3.遍历元素</span><br><span class="line">    //3.1使用迭代器</span><br><span class="line">    Iterator iterator=arrayList.iterator();</span><br><span class="line">    while(iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    //3.2使用列表迭代器</span><br><span class="line">    ListIterator listIterator=arrayList.listIterator();</span><br><span class="line"></span><br><span class="line">    //从前往后遍历</span><br><span class="line">    while(listIterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(listIterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //从后往前遍历</span><br><span class="line">    while(listIterator.hasPrevious()) &#123;</span><br><span class="line">        System.out.println(listIterator.previous());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断</span><br><span class="line">    System.out.println(arrayList.isEmpty());</span><br><span class="line">    System.out.println(arrayList.contains(new Student(&quot;李四&quot;, 22)));</span><br><span class="line">    //注：与上文相同的问题。</span><br><span class="line">    //查找</span><br><span class="line">    System.out.println(arrayList.indexOf(s2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个关键性的问题，就是我们删除时，new的数据类型和已存在的相同时，仍然不能删除，因为地址不一样，而源码中需要比较地址是否相同，所以，如果我们需要，可以自己重写学生类的equals方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        //如果地址相同 那肯定一样了</span><br><span class="line">        if (this == o)</span><br><span class="line">            return true;</span><br><span class="line">        //如果传过来空指针或者类型不同 肯定不一样</span><br><span class="line">        if (o == null || getClass() != o.getClass())</span><br><span class="line">            return false;</span><br><span class="line">        //强转一下类型</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        //根据我们的需要重写 这里我们希望 如果名字和年龄都一样 则一样</span><br><span class="line">        return age == student.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayL源码分析"><a href="#ArrayL源码分析" class="headerlink" title="ArrayL源码分析"></a>ArrayL源码分析</h3><p>默认容量大小：<code>private static final int DEFAULT_CAPACITY = 10;</code></p>
<p>存放元素的数组：<code>transient Object[] elementData;</code></p>
<p>实际元素个数：<code>private int size;</code></p>
<p>创建对象时调用的无参构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//这是一个空的数组</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段源码说明当你没有向集合中添加任何元素时，集合容量为0。那么默认的10个容量怎么来的呢？</p>
<p>这就得看看add方法的源码了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设你new了一个数组，当前容量为0，size当然也为0。这时调用add方法进入到<code>ensureCapacityInternal(size + 1);</code>该方法源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中的参数minCapacity传入的值为size+1也就是 1，接着我们再进入到<code>calculateCapacity(elementData, minCapacity)</code>里面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    return minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>elementData就是存放元素的数组，当前容量为0，if条件成立，返回默认容量<code>DEFAULT_CAPACITY</code>也就是10。这个值作为参数又传入<code>ensureExplicitCapacity()</code>方法中，进入该方法查看源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>先不要管modCount这个变量。</del></p>
<p>因为elementData数组长度为0，所以if条件成立，调用grow方法，<strong>重要的部分来了</strong>，我们再次进入到grow方法的源码中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法先声明了一个oldCapacity变量将数组长度赋给它，其值为0；又声明了一个newCapacity变量其值为<code>oldCapacity+一个增量</code>，可以发现这个增量是和原数组长度有关的量，当然在这里也为0。第一个if条件满足，newCapacity的值为10（这就是默认的容量，不理解的话再看看前面）。第二个if条件不成立，也可以不用注意，因为MAX_ARRAY_SIZE的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br></pre></td></tr></table></figure>

<p>这个值太大了以至于第二个if条件没有了解的必要。</p>
<p>最后一句话就是为elementData数组赋予了新的长度，<code>Arrays.copyOf()</code>方法返回的数组是新的数组对象，原数组对象不会改变，该拷贝不会影响原来的数组。<code>copyOf()</code>的第二个自变量指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值。</p>
<p>这时候再回到add的方法中，接着就向下执行<code>elementData[size++] = e;</code>到这里为止关于ArrayList就讲解得差不多了，当数组长度为10的时候你们可以试着过一下源码，查一下每次的增量是多少（答案是每次扩容为原来的1.5倍）。</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>数组结构实现，查询快、增删慢；</p>
<p>JDK1.0版本，运行效率慢、线程安全。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  @Test</span><br><span class="line">  public void VectorTest01()&#123;</span><br><span class="line">      Vector vector=new Vector();</span><br><span class="line">      vector.add(&quot;张三&quot;);</span><br><span class="line">      vector.add(&quot;李四&quot;);</span><br><span class="line">      vector.add(&quot;王五&quot;);</span><br><span class="line">      System.out.println(&quot;元素个数为：&quot;+vector.size());</span><br><span class="line">      //遍历</span><br><span class="line">      //枚举器</span><br><span class="line">      Enumeration enumeration=vector.elements();</span><br><span class="line">      while (enumeration.hasMoreElements())&#123;</span><br><span class="line">          System.out.println(enumeration.nextElement());</span><br><span class="line">      &#125;</span><br><span class="line">      //判断</span><br><span class="line">System.out.println(vector.isEmpty());</span><br><span class="line">System.out.println(vector.contains(&quot;王五&quot;));</span><br><span class="line">//Vector其他方法</span><br><span class="line">//firstElement()  lastElement()  ElementAt();</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>链表结构实现，增删快，查询慢。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"> public void LinkedListTest01()&#123;</span><br><span class="line">    LinkedList linkedList=new LinkedList&lt;&gt;();</span><br><span class="line">    Student s1=new Student(&quot;张三&quot;, 21);</span><br><span class="line">    Student s2=new Student(&quot;李四&quot;, 22);</span><br><span class="line">    Student s3=new Student(&quot;王五&quot;, 21);</span><br><span class="line">    //1.添加元素</span><br><span class="line">    linkedList.add(s1);</span><br><span class="line">    linkedList.add(s2);</span><br><span class="line">    linkedList.add(s3);</span><br><span class="line">    System.out.println(&quot;元素个数：&quot;+linkedList.size());</span><br><span class="line">    System.out.println(linkedList);</span><br><span class="line"></span><br><span class="line">    //遍历</span><br><span class="line">    //普通for</span><br><span class="line">    for(int i=0;i&lt;linkedList.size();i++)&#123;</span><br><span class="line">        System.out.println(linkedList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-----------&quot;);</span><br><span class="line">    //加强for</span><br><span class="line">    for(Object object:linkedList)&#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-----------&quot;);</span><br><span class="line">    //迭代器</span><br><span class="line">    Iterator iterator=linkedList.iterator();</span><br><span class="line">    while(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-----------&quot;);</span><br><span class="line">    //列表迭代器</span><br><span class="line">    ListIterator listIterator=linkedList.listIterator();</span><br><span class="line">    //从前往后遍历</span><br><span class="line">    while(listIterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(listIterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-----------&quot;);</span><br><span class="line">    //从后往前遍历</span><br><span class="line">    while(listIterator.hasPrevious()) &#123;</span><br><span class="line">        System.out.println(listIterator.previous());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h3><p>LinkedList首先有三个属性：</p>
<p>链表大小：<code>transient int size = 0;</code></p>
<p>（指向）第一个结点/头结点：<code> transient Node&lt;E&gt; first;</code></p>
<p>（指向）最后一个结点/尾结点：<code>transient Node&lt;E&gt; last;</code></p>
<p>关于Node类型我们再进入到类里看看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">COPYprivate static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先item存放的是实际数据；next指向下一个结点而prev指向上一个结点。</p>
<p>Node带参构造方法的三个参数分别是前一个结点、存储的数据、后一个结点，调用这个构造方法时将它们赋值给当前对象。</p>
<p>LinkedList是如何添加元素的呢？先看看add方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入到linkLast方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">COPYvoid linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设刚开始new了一个LinkedList对象，first和last属性都为空，调用add进入到linkLast方法。</p>
<p>首先创建一个Node变量 l 将last（此时为空）赋给它，然后new一个newNode变量存储数据，并且它的前驱指向l，后继指向null；再把last指向newNode。如下图所示：</p>
<p><img src="https://pic.downk.cc/item/5f9a62a01cd1bbb86bc58487.png" alt="img"></p>
<p>如果满足if条件，说明这是添加的第一个结点，将first指向newNode：</p>
<p><img src="https://pic.downk.cc/item/5f9a631c1cd1bbb86bc59ca6.png" alt="img"></p>
<p>至此，LinkedList对象的第一个数据添加完毕。假设需要再添加一个数据，我们可以再来走一遍，过程同上不再赘述，图示如下：</p>
<p><img src="https://pic.downk.cc/item/5f9a680e1cd1bbb86bc681f6.png" alt="img"></p>
<h3 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a><strong>ArrayList和LinkedList区别</strong></h3><p>ArrayList：必须开辟连续空间，查询快，增删慢。</p>
<p>LinkedList：无需开辟连续空间，查询慢，增删快。</p>
<p><img src="https://pic.downk.cc/item/5f9a6b371cd1bbb86bc74cda.png" alt="img"></p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Java泛型是JDK1.5中引入的一个新特性，其本质是参数化类型，把类型作为参数传递。</p>
<p>常见形式有泛型类、泛型接口、泛型方法。</p>
<p>语法：</p>
<p>&lt;T,…&gt; T称为类型占位符，表示一种引用类型。</p>
<p>好处：</p>
<p>提高代码的重用性。</p>
<p>防止类型转换异常，提高代码的安全性。</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 泛型类</span><br><span class="line"> * 语法：类名&lt;T&gt;</span><br><span class="line"> * T是类型占位符，表示一种引用类型，编写多个使用逗号隔开</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class myGeneric&lt;T&gt;&#123;</span><br><span class="line">	//1.创建泛型变量</span><br><span class="line">	//不能使用new来创建，因为泛型是不确定的类型，也可能拥有私密的构造方法。</span><br><span class="line">	T t;</span><br><span class="line">	//T t2=new T(); 泛型不能实例化 因为构造方法可能私有 可能没有无 参构造</span><br><span class="line">	//2.泛型作为方法的参数</span><br><span class="line">	public void show(T t) &#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">	&#125;</span><br><span class="line">	//泛型作为方法的返回值</span><br><span class="line">	public T getT() &#123;</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 泛型接口</span><br><span class="line"> * 语法：接口名&lt;T&gt;</span><br><span class="line"> * 注意：不能创建泛型静态常量</span><br><span class="line"> */</span><br><span class="line">public interface MyInterface&lt;T&gt; &#123;</span><br><span class="line">    //创建常量</span><br><span class="line">	String nameString=&quot;tang&quot;;</span><br><span class="line">    </span><br><span class="line">	T server(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现接口时确定泛型类</span><br><span class="line"> */</span><br><span class="line">public class MyInterfaceImpl implements MyInterface&lt;String&gt;&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public String server(String t) &#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">		return t; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//测试</span><br><span class="line">MyInterfaceImpl myInterfaceImpl=new MyInterfaceImpl();</span><br><span class="line">myInterfaceImpl.server(&quot;zhu&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现接口时不确定泛型类</span><br><span class="line"> */</span><br><span class="line">public class MyInterfaceImpl2&lt;T&gt; implements MyInterface&lt;T&gt;&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public T server(T t) &#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//测试</span><br><span class="line">MyInterfaceImpl2&lt;Integer&gt; myInterfaceImpl2=new MyInterfaceImpl2&lt;Integer&gt;();</span><br><span class="line">myInterfaceImpl2.server(2000);</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 泛型方法</span><br><span class="line"> * 语法：&lt;T&gt; 返回类型</span><br><span class="line"> */</span><br><span class="line">public class MyGenericMethod &#123;</span><br><span class="line">	public &lt;T&gt; void show(T t) &#123;</span><br><span class="line">		System.out.println(&quot;泛型方法&quot;+t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//测试</span><br><span class="line">MyGenericMethod myGenericMethod=new MyGenericMethod();</span><br><span class="line">myGenericMethod.show(&quot;tang&quot;);</span><br><span class="line">myGenericMethod.show(200);</span><br><span class="line">myGenericMethod.show(3.14);</span><br></pre></td></tr></table></figure>

<h3 id="泛型好处"><a href="#泛型好处" class="headerlink" title="泛型好处"></a>泛型好处</h3><p>提高代码重用性</p>
<p>防止类型转换异常，提高代码安全性</p>
<h3 id="泛型集合"><a href="#泛型集合" class="headerlink" title="泛型集合"></a>泛型集合</h3><ul>
<li><p><strong>概念</strong>：参数化类型、类型安全的集合，强制集合元素的类型必须一致。</p>
</li>
<li><p>特点</p>
<p>：</p>
<ul>
<li>编译时即可检查，而非运行时抛出异常。</li>
<li>访问时，不必类型转换（拆箱）。</li>
<li>不同泛型指尖引用不能相互赋值，泛型不存在多态。</li>
</ul>
</li>
</ul>
<p>之前我们在创建LinkedList类型对象的时候并没有使用泛型，但是进到它的源码中会发现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;//略&#125;</span><br></pre></td></tr></table></figure>

<p>它是一个泛型类，而我之前使用的时候并没有传递，说明java语法是允许的，这个时候传递的类型是Object类，虽然它是所有类的父类，可以存储任意的类型，但是在遍历、获取元素时需要原来的类型就要进行强制转换。这个时候就会出现一些问题，假如往链表里存储了许多不同类型的数据，在强转的时候就要判断每一个原来的类型，这样就很容易出现错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1=new ArrayList();</span><br><span class="line">arrayList1.add(&quot;223&quot;);</span><br><span class="line">//arrayList1.add(123);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Student&gt; arrayList2=new ArrayList&lt;&gt;();</span><br><span class="line">arrayList2.add(s1);</span><br></pre></td></tr></table></figure>

<p>通过泛型只能传入某一种数据，避免错误发生</p>
<h2 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h2><h3 id="set子接口"><a href="#set子接口" class="headerlink" title="set子接口"></a>set子接口</h3><ul>
<li><strong>特点</strong>：无序、无下标、元素不可重复。</li>
<li><strong>方法</strong>：全部继承自Collection中的方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void SetTest01()&#123;</span><br><span class="line">    Set&lt;String&gt; set=new HashSet&lt;String&gt;();</span><br><span class="line">    //1.添加数据</span><br><span class="line">    set.add(&quot;ming&quot;);</span><br><span class="line">    set.add(&quot;ren&quot;);</span><br><span class="line">    set.add(&quot;zuo&quot;);</span><br><span class="line">    System.out.println(&quot;数据个数：&quot;+set.size());</span><br><span class="line">    System.out.println(set.toString());//无序输出</span><br><span class="line">    //2.删除数据</span><br><span class="line">    /*</span><br><span class="line">     * set.remove(&quot;ren&quot;); System.out.println(set.toString());</span><br><span class="line">     */</span><br><span class="line">    //3.遍历【重点】</span><br><span class="line">    //3.1 使用增强for</span><br><span class="line">    for (String string : set) &#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">    //3.2 使用迭代器</span><br><span class="line">    Iterator&lt;String&gt; iterator=set.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    //4.判断</span><br><span class="line">    System.out.println(set.contains(&quot;ming&quot;));</span><br><span class="line">    System.out.println(set.isEmpty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set实现类"><a href="#set实现类" class="headerlink" title="set实现类"></a>set实现类</h3><h4 id="HashSet-重点"><a href="#HashSet-重点" class="headerlink" title="HashSet(重点)"></a>HashSet(重点)</h4><ul>
<li><p>基于HashCode计算元素存放位置。</p>
</li>
<li><p>当存入元素的哈希码相同时，会调用equals进行确认，如结果为true，则拒绝后者存入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void HashSetTest01()&#123;</span><br><span class="line">    HashSet&lt;Person&gt; hashSet=new HashSet&lt;&gt;();</span><br><span class="line">    Person p1=new Person(&quot;mi&quot;,21);</span><br><span class="line">    Person p2=new Person(&quot;ng&quot;, 22);</span><br><span class="line">    Person p3=new Person(&quot;ren&quot;, 21);</span><br><span class="line">    //1.添加元素</span><br><span class="line">    hashSet.add(p1);</span><br><span class="line">    hashSet.add(p2);</span><br><span class="line">    hashSet.add(p3);</span><br><span class="line">    //重复，添加失败</span><br><span class="line">    hashSet.add(p3);</span><br><span class="line">    //直接new一个相同属性的对象，依然会被添加，不难理解。</span><br><span class="line">    //假如相同属性便认为是同一个对象，怎么修改？</span><br><span class="line">    hashSet.add(new Person(&quot;mi&quot;, 21));</span><br><span class="line">    System.out.println(hashSet.toString());</span><br><span class="line">    //2.删除元素</span><br><span class="line">    hashSet.remove(p2);</span><br><span class="line">    //3.遍历</span><br><span class="line">    //3.1 增强for</span><br><span class="line">    for (Person person : hashSet) &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">    //3.2 迭代器</span><br><span class="line">    Iterator&lt;Person&gt; iterator=hashSet.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    //4.判断</span><br><span class="line">    System.out.println(hashSet.isEmpty());</span><br><span class="line">    //直接new一个相同属性的对象结果输出是false，不难理解。</span><br><span class="line">    //注：假如相同属性便认为是同一个对象，该怎么做？</span><br><span class="line">    System.out.println(hashSet.contains(new Person(&quot;mi&quot;, 21)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注</strong>：hashSet存储过程：</p>
<ol>
<li>根据hashCode计算保存的位置，如果位置为空，则直接保存，否则执行第二步。</li>
<li>执行equals方法，如果方法返回true，则认为是重复，拒绝存储，否则形成链表。</li>
</ol>
<p>存储过程实际上就是重复依据，要实现“注”里的问题，可以重写hashCode和equals代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    if (this == o) return true;</span><br><span class="line">    if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">    Person person = (Person) o;</span><br><span class="line">    return age == person.age &amp;&amp;</span><br><span class="line">            Objects.equals(name, person.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    return Objects.hash(name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul>
<li><p>基于排序顺序实现不重复。</p>
</li>
<li><p>实现了SortedSet接口，对集合元素自动排序。</p>
</li>
<li><p>元素对象的类型必须实现Comparable接口，指定排序规则。</p>
</li>
<li><p>通过CompareTo方法确定是否为重复元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void TreeSetTest01()&#123;</span><br><span class="line">    TreeSet&lt;Person&gt; persons=new TreeSet&lt;Person&gt;();</span><br><span class="line">    Person p1=new Person(&quot;mi&quot;,21);</span><br><span class="line">    Person p2=new Person(&quot;ng&quot;, 22);</span><br><span class="line">    Person p3=new Person(&quot;ren&quot;, 21);</span><br><span class="line">    //1.添加元素</span><br><span class="line">    persons.add(p1);</span><br><span class="line">    persons.add(p2);</span><br><span class="line">    persons.add(p3);</span><br><span class="line">    //注：直接添加会报类型转换错误，需要实现Comparable接口</span><br><span class="line">    System.out.println(persons.toString());</span><br><span class="line">    //2.删除元素</span><br><span class="line">    //persons.remove(p1);</span><br><span class="line">    persons.remove(new Person(&quot;ng&quot;, 22));</span><br><span class="line">    System.out.println(persons.toString());</span><br><span class="line">    //3.遍历（略）</span><br><span class="line">     for(Person person:persons)&#123;</span><br><span class="line">         System.out.println(person);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    Iterator iterator=persons.iterator();</span><br><span class="line">     while (iterator.hasNext())&#123;</span><br><span class="line">         System.out.println(iterator.next());</span><br><span class="line">     &#125;</span><br><span class="line">    //4.判断</span><br><span class="line">    System.out.println(persons.contains(new Person(&quot;mi&quot;, 21)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>//注：直接添加会报类型转换错误，需要实现Comparable接口</p>
<p>查看Comparable接口的源码，发现只有一个compareTo抽象方法，在人类中实现它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Person implements Comparable&lt;Person&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">	//1.先按姓名比</span><br><span class="line">	//2.再按年龄比</span><br><span class="line">	public int compareTo(Person o) &#123;</span><br><span class="line">		int n1=this.getName().compareTo(o.getName());</span><br><span class="line">		int n2=this.age-o.getAge();</span><br><span class="line">		return n1==0?n2:n1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了实现Comparable接口里的比较方法，TreeSet也提供了一个带比较器Comparator的构造方法，使用匿名内部类来实现它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Person&gt; persons=new TreeSet&lt;Person&gt;(new Comparator&lt;Person&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public int compare(Person o1, Person o2) &#123;</span><br><span class="line">				// 先按年龄比较</span><br><span class="line">				// 再按姓名比较</span><br><span class="line">				int n1=o1.getAge()-o2.getAge();</span><br><span class="line">				int n2=o1.getName().compareTo(o2.getName());</span><br><span class="line">				return n1==0?n2:n1;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;);</span><br><span class="line">		Person p1=new Person(&quot;tang&quot;,21);</span><br><span class="line">		Person p2=new Person(&quot;he&quot;, 22);</span><br><span class="line">		Person p3=new Person(&quot;yu&quot;, 21);</span><br><span class="line">		persons.add(p1);</span><br><span class="line">		persons.add(p2);</span><br><span class="line">		persons.add(p3);</span><br><span class="line">		System.out.println(persons.toString());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来做一个小案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 要求：使用TreeSet集合实现字符串按照长度进行排序</span><br><span class="line"> * helloworld tangrui hechengyang wangzixu yuguoming</span><br><span class="line"> * Comparator接口实现定制比较</span><br><span class="line"> */</span><br><span class="line">public class Demo6 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		TreeSet&lt;String&gt; treeSet=new TreeSet&lt;String&gt;(new Comparator&lt;String&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			//先比较字符串长度</span><br><span class="line">			//再比较字符串</span><br><span class="line">			public int compare(String o1, String o2) &#123;</span><br><span class="line">				int n1=o1.length()-o2.length();</span><br><span class="line">				int n2=o1.compareTo(o2);</span><br><span class="line">				return n1==0?n2:n1;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;);</span><br><span class="line">		treeSet.add(&quot;helloworld&quot;);</span><br><span class="line">		treeSet.add(&quot;tangrui&quot;);</span><br><span class="line">		treeSet.add(&quot;hechenyang&quot;);</span><br><span class="line">		treeSet.add(&quot;yuguoming&quot;);</span><br><span class="line">		treeSet.add(&quot;wangzixu&quot;);</span><br><span class="line">		System.out.println(treeSet.toString());</span><br><span class="line">        //输出[tangrui, wangzixu, yuguoming, hechenyang, helloworld]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><ul>
<li><p><strong>特点</strong>：存储一对数据（Key-Value），无序、无下标，键不可重复。</p>
</li>
<li><p><strong>方法</strong>：</p>
<p>V put(K key,V value)//将对象存入到集合中，关联键值。key重复则覆盖原值。</p>
</li>
<li><p>Object get(Object key)//根据键获取相应的值。</p>
<p>Set<K>//返回所有的key</K></p>
<p>Collection<V> values()//返回包含所有值的Collection集合。</V></p>
<p>Set&lt;Map.Entry&lt;K,V&gt;&gt;//键值匹配的set集合</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void MapTest01()&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map=new HashMap&lt;String, Integer&gt;();</span><br><span class="line">        //1.添加元素</span><br><span class="line">        map.put(&quot;mi&quot;, 21);</span><br><span class="line">        map.put(&quot;ng&quot;, 22);</span><br><span class="line">        map.put(&quot;ren&quot;, 23);</span><br><span class="line">        map.put(&quot;mi&quot;, 25);        //覆盖第一个</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        //2.删除元素</span><br><span class="line">        map.remove(&quot;ng&quot;);</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        //3.遍历</span><br><span class="line">        //3.1 使用keySet();</span><br><span class="line">        for (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key+&quot; &quot;+map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        //3.2 使用entrySet();效率较高</span><br><span class="line">        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey()+&quot; &quot;+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map实现类"><a href="#Map实现类" class="headerlink" title="Map实现类"></a>Map实现类</h3><h4 id="HashMap-重点"><a href="#HashMap-重点" class="headerlink" title="HashMap(重点)"></a>HashMap(重点)</h4><p>JDK1.2版本，线程不安全，运行效率快；允许用null作为key或是value。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void HashMapTest01()&#123;</span><br><span class="line">    HashMap&lt;Student, String&gt; hashMap=new HashMap&lt;Student, String&gt;();</span><br><span class="line">    Student s1=new Student(&quot;mi&quot;, 36);</span><br><span class="line">    Student s2=new Student(&quot;ng&quot;, 101);</span><br><span class="line">    Student s3=new Student(&quot;ren&quot;, 10);</span><br><span class="line">    //1.添加元素</span><br><span class="line">    hashMap.put(s1, &quot;成都&quot;);</span><br><span class="line">    hashMap.put(s2, &quot;杭州&quot;);</span><br><span class="line">    hashMap.put(s3, &quot;郑州&quot;);</span><br><span class="line">    //添加失败，但会更新值</span><br><span class="line">    hashMap.put(s3,&quot;上海&quot;);</span><br><span class="line">    //添加成功，不过两个属性一模一样；</span><br><span class="line">    //注：假如相同属性便认为是同一个对象，怎样修改？</span><br><span class="line">    hashMap.put(new Student(&quot;ren&quot;, 10),&quot;上海&quot;);</span><br><span class="line">    System.out.println(hashMap.toString());</span><br><span class="line">    //2.删除元素</span><br><span class="line">    hashMap.remove(s3);</span><br><span class="line">    System.out.println(hashMap.toString());</span><br><span class="line">    //3.遍历</span><br><span class="line">    //3.1 使用keySet()遍历</span><br><span class="line">    for (Student key : hashMap.keySet()) &#123;</span><br><span class="line">        System.out.println(key+&quot; &quot;+hashMap.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    //3.2 使用entrySet()遍历</span><br><span class="line">    for (Map.Entry&lt;Student, String&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">        System.out.println(entry.getKey()+&quot; &quot;+entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    //4.判断</span><br><span class="line">    //注：同上</span><br><span class="line">    System.out.println(hashMap.containsKey(new Student(&quot;he&quot;, 10)));</span><br><span class="line">    System.out.println(hashMap.containsValue(&quot;成都&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：和之前说过的HashSet类似，重复依据是hashCode和equals方法，重写即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public int hashCode() &#123;</span><br><span class="line">      final int prime = 31;</span><br><span class="line">      int result = 1;</span><br><span class="line">      result = prime * result + id;</span><br><span class="line">      result = prime * result + ((name == null) ? 0 : name.hashCode());</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean equals(Object obj) &#123;</span><br><span class="line">      if (this == obj)</span><br><span class="line">          return true;</span><br><span class="line">      if (obj == null)</span><br><span class="line">          return false;</span><br><span class="line">      if (getClass() != obj.getClass())</span><br><span class="line">          return false;</span><br><span class="line">      Student other = (Student) obj;</span><br><span class="line">      if (id != other.id)</span><br><span class="line">          return false;</span><br><span class="line">      if (name == null) &#123;</span><br><span class="line">          if (other.name != null)</span><br><span class="line">              return false;</span><br><span class="line">      &#125; else if (!name.equals(other.name))</span><br><span class="line">          return false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a><strong>HashMap源码分析</strong></h4></li>
<li><p>默认初始化容量：<code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</code></p>
<ul>
<li>数组最大容量：<code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code></li>
</ul>
</li>
<li><p>默认加载因子：<code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></p>
</li>
<li><p>链表调整为红黑树的链表长度阈值（JDK1.8）：<code>static final int TREEIFY_THRESHOLD = 8;</code></p>
</li>
<li><p>红黑树调整为链表的链表长度阈值（JDK1.8）：<code>static final int UNTREEIFY_THRESHOLD = 6;</code></p>
</li>
<li><p>链表调整为红黑树的数组最小阈值（JDK1.8）：<code>static final int MIN_TREEIFY_CAPACITY = 64;</code></p>
</li>
<li><p>HashMap存储的数组：<code>transient Node&lt;K,V&gt;[] table;</code></p>
</li>
<li><p>HashMap存储的元素个数：<code>transient int size;</code></p>
<blockquote>
<ul>
<li>默认加载因子是什么？<ul>
<li>就是判断数组是否扩容的一个因子。假如数组容量为100，如果HashMap的存储元素个数超过了100*0.75=75，那么就会进行扩容。</li>
</ul>
</li>
<li>链表调整为红黑树的链表长度阈值是什么？<ul>
<li>假设在数组中下标为3的位置已经存储了数据，当新增数据时通过哈希码得到的存储位置又是3，那么就会在该位置形成一个链表，当链表过长时就会转换成红黑树以提高执行效率，这个阈值就是链表转换成红黑树的最短链表长度；</li>
</ul>
</li>
<li>红黑树调整为链表的链表长度阈值是什么？<ul>
<li>当红黑树的元素个数小于该阈值时就会转换成链表。</li>
</ul>
</li>
<li>链表调整为红黑树的数组最小阈值是什么？<ul>
<li>并不是只要链表长度大于8就可以转换成红黑树，在前者条件成立的情况下，数组的容量必须大于等于64才会进行转换。</li>
</ul>
</li>
</ul>
</blockquote>
<p>HashMap的数组table存储的就是一个个的Node&lt;K,V&gt;类型，很清晰地看到有一对键值，还有一个指向next的指针（以下只截取了部分源码）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COPYstatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">      final K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>之前的代码中在new对象时调用的是HashMap的无参构造方法，进入到该构造方法的源码查看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic HashMap() &#123;</span><br><span class="line">      this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>发现没什么内容，只是赋值了一个默认加载因子；而在上文我们观察到源码中table和size都没有赋予初始值，说明刚创建的HashMap对象没有分配容量，并不拥有默认的16个空间大小，这样做的目的是为了节约空间，此时table为null，size为0。</p>
<p>当我们往对象里添加元素时调用put方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic V put(K key, V value) &#123;</span><br><span class="line">      return putVal(hash(key), key, value, false, true);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>put方法把key和value传给了putVal，同时还传入了一个hash(Key)所返回的值，这是一个产生哈希值的方法，再进入到putVal方法（部分源码）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">COPYfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                    boolean evict) &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">      if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">      if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">          tab[i] = newNode(hash, key, value, null);</span><br><span class="line">      else&#123;</span><br><span class="line">          //略</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里面创建了一个tab数组和一个Node变量p，第一个if实际是判断table是否为空，而我们现在只关注刚创建HashMap对象时的状态，此时tab和table都为空，满足条件，执行内部代码，这条代码其实就是把resize()所返回的结果赋给tab，n就是tab的长度，resize顾名思义就是重新调整大小。查看resize()源码（部分）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">COPYfinal Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">      int oldThr = threshold;</span><br><span class="line">      if (oldCap &gt; 0);</span><br><span class="line">      else if (oldThr &gt; 0);</span><br><span class="line">      else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125; </span><br><span class="line">      @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      return newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>该方法首先把table及其长度赋值给oldTab和oldCap；threshold是阈值的意思，此时为0，所以前两个if先不管，最后else里newCap的值为默认初始化容量16；往下创建了一个newCap大小的数组并将其赋给了table，刚创建的HashMap对象就在这里获得了初始容量。然后我们再回到putVal方法，第二个if就是根据哈希码得到的tab中的一个位置是否为空，为空便直接添加元素，此时数组中无元素所以直接添加。至此HashMap对象就完成了第一个元素的添加。当添加的元素超过16*0.75=12时，就会进行扩容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COPYfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)&#123;</span><br><span class="line">      if (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>扩容的代码如下（部分）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">COPYfinal Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">      int newCap;</span><br><span class="line">      if (oldCap &gt; 0) &#123;</span><br><span class="line">          if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//略&#125;</span><br><span class="line">          else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>核心部分是else if里的移位操作，<strong>也就是说每次扩容都是原来大小的两倍</strong>。</p>
</li>
<li><p>*注**：额外说明的一点是在JDK1.8以前链表是头插入，JDK1.8以后链表是尾插入。</p>
</li>
</ul>
<hr>
<h4 id="HashSet源码分析"><a href="#HashSet源码分析" class="headerlink" title="HashSet源码分析"></a><strong>HashSet源码分析</strong></h4><p>了解完HashMap之后，再回过头来看之前的HashSet源码，为什么放在后面写你们看一下源码就知道了（部分）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic class HashSet&lt;E&gt;</span><br><span class="line">      extends AbstractSet&lt;E&gt;</span><br><span class="line">      implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">  &#123;</span><br><span class="line">      private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">      private static final Object PRESENT = new Object();</span><br><span class="line">      public HashSet() &#123;</span><br><span class="line">          map = new HashMap&lt;&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看见HashSet的存储结构就是HashMap，那它的存储方式是怎样的呢？可以看一下add方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic boolean add(E e) &#123;</span><br><span class="line">      return map.put(e, PRESENT)==null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>很明了地发现它的add方法调用的就是map的put方法，把元素作为map的key传进去的。。</p>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a><strong>Hashtable</strong></h4><ul>
<li><p>JDK1.0版本，线程安全，运行效率慢；不允许null作为key或是value。</p>
</li>
<li><p>初始容量11，加载因子0.75。</p>
<p>这个集合在开发过程中已经不用了，稍微了解即可。</p>
</li>
</ul>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a><strong>Properties</strong></h4><ul>
<li>Hashtable的子类，要求key和value都是String。通常用于配置文件的读取。</li>
</ul>
<p>它继承了Hashtable的方法，与流关系密切，此处不详解。</p>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>实现了SortedMap接口（是Map的子接口），可以对key自动排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Student, Integer&gt; treeMap=new TreeMap&lt;Student, Integer&gt;();</span><br><span class="line">		Student s1=new Student(&quot;tang&quot;, 36);</span><br><span class="line">		Student s2=new Student(&quot;yu&quot;, 101);</span><br><span class="line">		Student s3=new Student(&quot;he&quot;, 10);</span><br><span class="line">		//1.添加元素</span><br><span class="line">		treeMap.put(s1, 21);</span><br><span class="line">		treeMap.put(s2, 22);</span><br><span class="line">		treeMap.put(s3, 21);</span><br><span class="line">		//不能直接打印，需要实现Comparable接口，因为红黑树需要比较大小</span><br><span class="line">		System.out.println(treeMap.toString());</span><br><span class="line">		//2.删除元素</span><br><span class="line">		treeMap.remove(new Student(&quot;he&quot;, 10));</span><br><span class="line">		System.out.println(treeMap.toString());</span><br><span class="line">		//3.遍历</span><br><span class="line">		//3.1 使用keySet()</span><br><span class="line">		for (Student key : treeMap.keySet()) &#123;</span><br><span class="line">			System.out.println(key+&quot; &quot;+treeMap.get(key));</span><br><span class="line">		&#125;</span><br><span class="line">		//3.2 使用entrySet()</span><br><span class="line">		for (Entry&lt;Student, Integer&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">			System.out.println(entry.getKey()+&quot; &quot;+entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">		//4.判断</span><br><span class="line">		System.out.println(treeMap.containsKey(s1));</span><br><span class="line">		System.out.println(treeMap.isEmpty());		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在学生类中实现Comparable接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Comparable&lt;Student&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Student o) &#123;</span><br><span class="line">        int n1=this.id-o.id;</span><br><span class="line">        return n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外还可以使用比较器来定制比较：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Student, Integer&gt; treeMap2=new TreeMap&lt;Student, Integer&gt;(new Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Student o1, Student o2) &#123;</span><br><span class="line">        // 略</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;			</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="TreeSet源码"><a href="#TreeSet源码" class="headerlink" title="TreeSet源码"></a><strong>TreeSet源码</strong></h4><p>和HashSet类似，放在TreeMap之后讲便一目了然（部分）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;</span><br><span class="line">    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    private transient NavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    private static final Object PRESENT = new Object();</span><br><span class="line">    TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">        this.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeSet() &#123;</span><br><span class="line">        this(new TreeMap&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeSet的存储结构实际上就是TreeMap，再来看其存储方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic boolean add(E e) &#123;</span><br><span class="line">    return m.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的add方法调用的就是TreeMap的put方法，将元素作为key传入到存储结构中。</p>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a><strong>Collections工具类</strong></h2><ul>
<li><p><strong>概念</strong>：集合工具类，定义了除了存取以外的集合常用方法。</p>
</li>
<li><p><strong>方法</strong>：</p>
<p>public static void reverse(List&lt;?&gt; list)//反转集合中元素的顺序</p>
<p>public static void shuffle(List&lt;?&gt; list)//随机重置集合元素的顺序</p>
<p>public static void sort(List<T> list)//升序排序（元素类型必须实现Comparable接口）</T></p>
</li>
</ul>
<p>List<Integer> list=new ArrayList<Integer>();<br>        list.add(20);<br>        list.add(10);<br>        list.add(30);<br>        list.add(90);<br>        list.add(70);</Integer></Integer></p>
<pre><code>    //sort排序
    System.out.println(list.toString());
    Collections.sort(list);
    System.out.println(list.toString());
    System.out.println(&quot;---------&quot;);
    
    //binarySearch二分查找
    int i=Collections.binarySearch(list, 10);
    System.out.println(i);
    
    //copy复制
    List&lt;Integer&gt; list2=new ArrayList&lt;Integer&gt;();
    for(int i1=0;i1&lt;5;++i1) &#123;
        list2.add(0);
    &#125;
    //该方法要求目标元素容量大于等于源目标
    Collections.copy(list2, list);
    System.out.println(list2.toString());
    
    //reserve反转
    Collections.reverse(list2);
    System.out.println(list2.toString());
    
    //shuffle 打乱
    Collections.shuffle(list2);
    System.out.println(list2.toString());
    
    //补充：list转成数组
    Integer[] arr=list.toArray(new Integer[0]);
    System.out.println(arr.length);
    //补充：数组转成集合 
    String[] nameStrings= &#123;&quot;tang&quot;,&quot;he&quot;,&quot;yu&quot;&#125;;
    //受限集合，不能添加和删除
    List&lt;String&gt; list3=Arrays.asList(nameStrings);
    System.out.println(list3);
    
    //注：基本类型转成集合时需要修改为包装类
&#125;
</code></pre>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/05/14/Linux/" rel="prev" title="">
                  <i class="fa fa-chevron-left"></i> 
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mingr</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
