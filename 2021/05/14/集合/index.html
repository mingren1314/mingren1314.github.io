<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>集合 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="集合什么是集合概念： 对象的容器，定义了对多个对象进项操作的的常用方法。可实现数组的功能。 和数组区别：  数组长度固定，集合长度不固定。 数组可以存储基本类型和引用类型，集合只能存储引用类型。  位置： java.util.*; Collection体系集合Collection父接口特点：代表一组任意类型的对象，无序、无下标、不能重复。 方法： 123456789boolean add(Obje">
<meta property="og:type" content="article">
<meta property="og:title" content="集合">
<meta property="og:url" content="https://mingren1314.github.io/2021/05/14/%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="集合什么是集合概念： 对象的容器，定义了对多个对象进项操作的的常用方法。可实现数组的功能。 和数组区别：  数组长度固定，集合长度不固定。 数组可以存储基本类型和引用类型，集合只能存储引用类型。  位置： java.util.*; Collection体系集合Collection父接口特点：代表一组任意类型的对象，无序、无下标、不能重复。 方法： 123456789boolean add(Obje">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic.downk.cc/item/5f9a62a01cd1bbb86bc58487.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f9a631c1cd1bbb86bc59ca6.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f9a680e1cd1bbb86bc681f6.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f9a6b371cd1bbb86bc74cda.png">
<meta property="article:published_time" content="2021-05-14T10:19:10.000Z">
<meta property="article:modified_time" content="2021-05-14T10:21:14.691Z">
<meta property="article:author" content="mingr">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.downk.cc/item/5f9a62a01cd1bbb86bc58487.png">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="//img/tx.jpg">
  
  
      
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true
      }
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/tx.jpg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="https://mingren1314.github.io/archives/">博客首页</a></li>
                        
                            <li><a  href="/archives">文章归档</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="https://github.com/mingren1314" title="github">github</a>
                            
                                <a class="fl QQ"  target="_blank" href="http://wpa.qq.com/msgrd?v=3&uin=2674672641&site=qq&menu=yes" title="QQ">QQ</a>
                            
                                <a class="fl wechat"  target="_blank" href="/img/wx.jpg" title="wechat">wechat</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://ring3.xyz/">Yllen</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://mxny.org/">麦香浓郁</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://whereisk0shl.top/">K0sh1</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.ycjcl.cc/">信鑫</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://bystudent.com/">ByStundet表哥</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.jarviswang.me/">汪神_Jarvis</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://sh3ll.me/">Chu</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.hackfun.org/">4ido10n</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/iamstudy">L3m0n</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://o0xmuhe.me/">muhe</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.nuptzj.cn/">_画船听雨</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.virzz.com/index.html">Virink</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.sqlsec.com/">国光</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.bodkin.ren/">老锥</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cizel.cn/">C1zel</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://1phan.cc">1phan</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.liuil.top/">liuil</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/Ox9A82/">Ox9A82</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://burnegg.com/">burnegg</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://jwrsec.cn/">jwr-sec</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://sudalover.cn/">苏打</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.binklac.com">VeroFess</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.bendawang.site/">bendawang</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://weeklyalgo.codes/">hook</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.flier.net.cn/">Flier&#39;blog</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.mutepig.club">mutepig</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://blog.iret.xyz/list.aspx">Silver</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://simp1e.leanote.com/">Simple</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://processor.pub/">Processor</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">性别男 爱好女</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="//img/tx.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="https://mingren1314.github.io/archives/">博客首页</a></li>
                
                    <li><a href="/archives">文章归档</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="https://github.com/mingren1314" title="github">github</a>
                    
                        <a class="QQ" target="_blank" href="http://wpa.qq.com/msgrd?v=3&uin=2674672641&site=qq&menu=yes" title="QQ">QQ</a>
                    
                        <a class="wechat" target="_blank" href="/img/wx.jpg" title="wechat">wechat</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-集合" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/05/14/%E9%9B%86%E5%90%88/" class="article-date">
      <time datetime="2021-05-14T10:19:10.000Z" itemprop="datePublished">2021-05-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      集合
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h2><p>概念：</p>
<p>对象的容器，定义了对多个对象进项操作的的常用方法。可实现数组的功能。</p>
<p>和数组区别：</p>
<ol>
<li>数组长度固定，集合长度不固定。</li>
<li>数组可以存储基本类型和引用类型，集合只能存储引用类型。</li>
</ol>
<p>位置：</p>
<p>java.util.*;</p>
<h2 id="Collection体系集合"><a href="#Collection体系集合" class="headerlink" title="Collection体系集合"></a>Collection体系集合</h2><h2 id="Collection父接口"><a href="#Collection父接口" class="headerlink" title="Collection父接口"></a>Collection父接口</h2><p><strong>特点</strong>：代表一组任意类型的对象，无序、无下标、不能重复。</p>
<p><strong>方法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">boolean add(Object obj) //添加一个对象。</span><br><span class="line">boolean addAll(Collection c) //讲一个集合中的所有对象添加到此集合中。</span><br><span class="line">void clear() //清空此集合中的所有对象。</span><br><span class="line">boolean contains(Object o) //检查此集合中是否包含o对象。</span><br><span class="line">boolean equals(Object o) //比较此集合是否与指定对象相等。</span><br><span class="line">boolean isEmpty() //判断此集合是否为空。</span><br><span class="line">boolean remove(Object o) //在此集合中移除o对象。</span><br><span class="line">int size() //返回此集合中的元素个数。</span><br><span class="line">Object[] toArray() //将此集合转换成数组。</span><br></pre></td></tr></table></figure>

<h3 id="Collection接口的使用1"><a href="#Collection接口的使用1" class="headerlink" title="Collection接口的使用1"></a>Collection接口的使用1</h3><pre><code>@Test
    public void CollectionTest01()&#123;
        //创建集合 Collection是接口 不能实例化 通过子类实例化
        Collection collection=new ArrayList();
        //添加元素
        collection.add(&quot;苹果&quot;);
        collection.add(&quot;香蕉&quot;);
        collection.add(&quot;梨&quot;);
        System.out.println(&quot;元素个数为：&quot;+collection.size());
        System.out.println(collection);//其实调用的是collection.toString方法

        //删除元素
        //collection.remove(&quot;香蕉&quot;);//clear()是清空元素
        System.out.println(&quot;元素个数为：&quot;+collection.size());
        System.out.println(collection);

        //遍历元素(重点)
        //通过增强for遍历
        for(Object object:collection)&#123;
            System.out.println(object);//可以像下面测试2一样强转一下类型 也可以不用强转
        &#125;

        //通过迭代器遍历
        Iterator it=collection.iterator();
        while(it.hasNext())&#123;//hasNext()方法 下一位置有无元素 Boolean
            //可以像下面测试2一样强转一下类型 也可以不用强转
            System.out.println(it.next());//返回指的位置的元素
            //it.remove();//可以用迭代器删除元素  但是不可以 collection.remove()这样删除元素
        &#125;

        //判断有无元素
        System.out.println(collection.contains(&quot;香蕉&quot;));
        System.out.println(collection.contains(&quot;西瓜&quot;));

        //判断是否为空
        System.out.println(collection.isEmpty());
    &#125;
</code></pre>
<h3 id="Collection接口的使用2"><a href="#Collection接口的使用2" class="headerlink" title="Collection接口的使用2"></a>Collection接口的使用2</h3><pre><code>   @Test
    public void CollectionTest02()&#123;
        //创建集合
        Collection collection=new ArrayList();

        Student student1=new Student(&quot;张三&quot;,15);
        Student student2=new Student(&quot;李四&quot;,18);
        Student student3=new Student(&quot;王五&quot;,20);

        //添加数据
        collection.add(student1);
        collection.add(student2);
        collection.add(student3);
        System.out.println(&quot;集合数据个数为：&quot;+collection.size());
        System.out.println(collection.toString());

        //删除数据
        collection.remove(student1);
        System.out.println(&quot;集合数据个数为：&quot;+collection.size());
        System.out.println(collection.toString());

        //遍历集合
        //增强for
        for(Object object:collection)&#123;
            Student stu=(Student)object;
            System.out.println(stu);
        &#125;

        System.out.println(&quot;---------------&quot;);
        //迭代器 迭代过程不能使用collection的删除方法
        Iterator it=collection.iterator();
        while(it.hasNext())&#123;
            Student stu=(Student) it.next();
            System.out.println(stu);
        &#125;
    &#125;
</code></pre>
<h3 id="学生类"><a href="#学生类" class="headerlink" title="学生类"></a>学生类</h3><pre><code>public class Student &#123;
    String name;
    int age;

    public Student(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<h2 id="Collection子接口"><a href="#Collection子接口" class="headerlink" title="Collection子接口"></a>Collection子接口</h2><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><p><strong>特点</strong>：有序、有下标、元素可以重复。</p>
<p><strong>方法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void add(int index,Object o) //在index位置插入对象o</span><br><span class="line"></span><br><span class="line">boolean addAll(index,Collection c) //将一个集合中的元素添加到此集合中的index位置。</span><br><span class="line"></span><br><span class="line">Object get(int index) //返回集合中指定位置的元素。</span><br><span class="line"></span><br><span class="line">List subList(int fromIndex,int toIndex) //返回fromIndex和toIndex之间的集合元素。</span><br></pre></td></tr></table></figure>

<h3 id="List集合的使用1"><a href="#List集合的使用1" class="headerlink" title="List集合的使用1"></a>List集合的使用1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void ListTest01()&#123;</span><br><span class="line">    //创建集合</span><br><span class="line">    List list=new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    //添加数据</span><br><span class="line">    list.add(&quot;张三&quot;);</span><br><span class="line">    list.add(&quot;李四&quot;);</span><br><span class="line">    list.add(0,&quot;王五&quot;);</span><br><span class="line">    System.out.println(&quot;数据个数为：&quot;+list.size());</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    //删除数据</span><br><span class="line">    list.remove(&quot;张三&quot;);//等同于 list.remove(0);</span><br><span class="line"></span><br><span class="line">    //遍历数据</span><br><span class="line">    //普通for循环</span><br><span class="line">    for(int i=0;i&lt;list.size();i++)&#123;</span><br><span class="line">        System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //加强for</span><br><span class="line">    for(Object object:list)&#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //迭代器</span><br><span class="line">    Iterator it=list.iterator();</span><br><span class="line">    while(it.hasNext())&#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-----------------------&quot;);</span><br><span class="line">    //使用列表迭代器，listIterator可以双向遍历，添加、删除及修改元素</span><br><span class="line">    ListIterator listIterator=list.listIterator();</span><br><span class="line"></span><br><span class="line">    //从前向后遍历</span><br><span class="line">    while(listIterator.hasNext())&#123;</span><br><span class="line">        System.out.println(listIterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-----------------------&quot;);</span><br><span class="line">    //从后向前(此时指针指向末尾)</span><br><span class="line">    while(listIterator.hasPrevious())&#123;</span><br><span class="line">        System.out.println(listIterator.previous());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-----------------------&quot;);</span><br><span class="line">    //判断</span><br><span class="line">    System.out.println(list.isEmpty());</span><br><span class="line">    System.out.println(list.contains(&quot;王五&quot;));</span><br><span class="line">    //获取位置</span><br><span class="line">    System.out.println(list.indexOf(&quot;李四&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List集合的使用2"><a href="#List集合的使用2" class="headerlink" title="List集合的使用2"></a>List集合的使用2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void ListTest02()&#123;</span><br><span class="line">    //创建集合</span><br><span class="line">    List list=new ArrayList();</span><br><span class="line"></span><br><span class="line">    //添加数字 自动装箱 20这些数字不再是基本数据类型了 而变成了包装类</span><br><span class="line">    list.add(20);</span><br><span class="line">    list.add(30);</span><br><span class="line">    list.add(40);</span><br><span class="line">    list.add(50);</span><br><span class="line">    list.add(60);</span><br><span class="line">    System.out.println(&quot;元素个数为：&quot;+list.size());</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    //删除操作</span><br><span class="line">    //list.remove(20);  如果想删除20 它调用的是数组下标 会越界报错 所以可以用下面两种方法</span><br><span class="line">    list.remove((Object)20);//法1</span><br><span class="line">    list.remove(new Integer(20));//法2</span><br><span class="line">    System.out.println(&quot;元素个数为：&quot;+list.size());</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    List list2=list.subList(1,3);//包含1 不包含3 (含头不含尾)</span><br><span class="line">    System.out.println(list2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>数组结构实现，查询块、增删慢；</p>
<p>JDK1.2版本，运行效率快、线程不安全。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void ArrayListTest01()&#123;</span><br><span class="line">    ArrayList arrayList=new ArrayList();</span><br><span class="line">    Student s1=new Student(&quot;张三&quot;, 21);</span><br><span class="line">    Student s2=new Student(&quot;李四&quot;, 22);</span><br><span class="line">    Student s3=new Student(&quot;王五&quot;, 21);</span><br><span class="line">    arrayList.add(s1);</span><br><span class="line">    arrayList.add(s2);</span><br><span class="line">    arrayList.add(s3);</span><br><span class="line">    System.out.println(&quot;元素个数：&quot;+arrayList.size());</span><br><span class="line">    System.out.println(arrayList.toString());</span><br><span class="line">    //2.删除元素</span><br><span class="line">    arrayList.remove(s1);</span><br><span class="line">    System.out.println(&quot;元素个数：&quot;+arrayList.size());</span><br><span class="line">    System.out.println(arrayList.toString());</span><br><span class="line">    //3.遍历元素</span><br><span class="line">    //3.1使用迭代器</span><br><span class="line">    Iterator iterator=arrayList.iterator();</span><br><span class="line">    while(iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    //3.2使用列表迭代器</span><br><span class="line">    ListIterator listIterator=arrayList.listIterator();</span><br><span class="line"></span><br><span class="line">    //从前往后遍历</span><br><span class="line">    while(listIterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(listIterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //从后往前遍历</span><br><span class="line">    while(listIterator.hasPrevious()) &#123;</span><br><span class="line">        System.out.println(listIterator.previous());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断</span><br><span class="line">    System.out.println(arrayList.isEmpty());</span><br><span class="line">    System.out.println(arrayList.contains(new Student(&quot;李四&quot;, 22)));</span><br><span class="line">    //注：与上文相同的问题。</span><br><span class="line">    //查找</span><br><span class="line">    System.out.println(arrayList.indexOf(s2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个关键性的问题，就是我们删除时，new的数据类型和已存在的相同时，仍然不能删除，因为地址不一样，而源码中需要比较地址是否相同，所以，如果我们需要，可以自己重写学生类的equals方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        //如果地址相同 那肯定一样了</span><br><span class="line">        if (this == o)</span><br><span class="line">            return true;</span><br><span class="line">        //如果传过来空指针或者类型不同 肯定不一样</span><br><span class="line">        if (o == null || getClass() != o.getClass())</span><br><span class="line">            return false;</span><br><span class="line">        //强转一下类型</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        //根据我们的需要重写 这里我们希望 如果名字和年龄都一样 则一样</span><br><span class="line">        return age == student.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayL源码分析"><a href="#ArrayL源码分析" class="headerlink" title="ArrayL源码分析"></a>ArrayL源码分析</h3><p>默认容量大小：<code>private static final int DEFAULT_CAPACITY = 10;</code></p>
<p>存放元素的数组：<code>transient Object[] elementData;</code></p>
<p>实际元素个数：<code>private int size;</code></p>
<p>创建对象时调用的无参构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//这是一个空的数组</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段源码说明当你没有向集合中添加任何元素时，集合容量为0。那么默认的10个容量怎么来的呢？</p>
<p>这就得看看add方法的源码了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设你new了一个数组，当前容量为0，size当然也为0。这时调用add方法进入到<code>ensureCapacityInternal(size + 1);</code>该方法源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中的参数minCapacity传入的值为size+1也就是 1，接着我们再进入到<code>calculateCapacity(elementData, minCapacity)</code>里面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    return minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>elementData就是存放元素的数组，当前容量为0，if条件成立，返回默认容量<code>DEFAULT_CAPACITY</code>也就是10。这个值作为参数又传入<code>ensureExplicitCapacity()</code>方法中，进入该方法查看源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>先不要管modCount这个变量。</del></p>
<p>因为elementData数组长度为0，所以if条件成立，调用grow方法，<strong>重要的部分来了</strong>，我们再次进入到grow方法的源码中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法先声明了一个oldCapacity变量将数组长度赋给它，其值为0；又声明了一个newCapacity变量其值为<code>oldCapacity+一个增量</code>，可以发现这个增量是和原数组长度有关的量，当然在这里也为0。第一个if条件满足，newCapacity的值为10（这就是默认的容量，不理解的话再看看前面）。第二个if条件不成立，也可以不用注意，因为MAX_ARRAY_SIZE的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br></pre></td></tr></table></figure>

<p>这个值太大了以至于第二个if条件没有了解的必要。</p>
<p>最后一句话就是为elementData数组赋予了新的长度，<code>Arrays.copyOf()</code>方法返回的数组是新的数组对象，原数组对象不会改变，该拷贝不会影响原来的数组。<code>copyOf()</code>的第二个自变量指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值。</p>
<p>这时候再回到add的方法中，接着就向下执行<code>elementData[size++] = e;</code>到这里为止关于ArrayList就讲解得差不多了，当数组长度为10的时候你们可以试着过一下源码，查一下每次的增量是多少（答案是每次扩容为原来的1.5倍）。</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>数组结构实现，查询快、增删慢；</p>
<p>JDK1.0版本，运行效率慢、线程安全。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  @Test</span><br><span class="line">  public void VectorTest01()&#123;</span><br><span class="line">      Vector vector=new Vector();</span><br><span class="line">      vector.add(&quot;张三&quot;);</span><br><span class="line">      vector.add(&quot;李四&quot;);</span><br><span class="line">      vector.add(&quot;王五&quot;);</span><br><span class="line">      System.out.println(&quot;元素个数为：&quot;+vector.size());</span><br><span class="line">      //遍历</span><br><span class="line">      //枚举器</span><br><span class="line">      Enumeration enumeration=vector.elements();</span><br><span class="line">      while (enumeration.hasMoreElements())&#123;</span><br><span class="line">          System.out.println(enumeration.nextElement());</span><br><span class="line">      &#125;</span><br><span class="line">      //判断</span><br><span class="line">System.out.println(vector.isEmpty());</span><br><span class="line">System.out.println(vector.contains(&quot;王五&quot;));</span><br><span class="line">//Vector其他方法</span><br><span class="line">//firstElement()  lastElement()  ElementAt();</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>链表结构实现，增删快，查询慢。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"> public void LinkedListTest01()&#123;</span><br><span class="line">    LinkedList linkedList=new LinkedList&lt;&gt;();</span><br><span class="line">    Student s1=new Student(&quot;张三&quot;, 21);</span><br><span class="line">    Student s2=new Student(&quot;李四&quot;, 22);</span><br><span class="line">    Student s3=new Student(&quot;王五&quot;, 21);</span><br><span class="line">    //1.添加元素</span><br><span class="line">    linkedList.add(s1);</span><br><span class="line">    linkedList.add(s2);</span><br><span class="line">    linkedList.add(s3);</span><br><span class="line">    System.out.println(&quot;元素个数：&quot;+linkedList.size());</span><br><span class="line">    System.out.println(linkedList);</span><br><span class="line"></span><br><span class="line">    //遍历</span><br><span class="line">    //普通for</span><br><span class="line">    for(int i=0;i&lt;linkedList.size();i++)&#123;</span><br><span class="line">        System.out.println(linkedList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-----------&quot;);</span><br><span class="line">    //加强for</span><br><span class="line">    for(Object object:linkedList)&#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-----------&quot;);</span><br><span class="line">    //迭代器</span><br><span class="line">    Iterator iterator=linkedList.iterator();</span><br><span class="line">    while(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-----------&quot;);</span><br><span class="line">    //列表迭代器</span><br><span class="line">    ListIterator listIterator=linkedList.listIterator();</span><br><span class="line">    //从前往后遍历</span><br><span class="line">    while(listIterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(listIterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;-----------&quot;);</span><br><span class="line">    //从后往前遍历</span><br><span class="line">    while(listIterator.hasPrevious()) &#123;</span><br><span class="line">        System.out.println(listIterator.previous());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h3><p>LinkedList首先有三个属性：</p>
<p>链表大小：<code>transient int size = 0;</code></p>
<p>（指向）第一个结点/头结点：<code> transient Node&lt;E&gt; first;</code></p>
<p>（指向）最后一个结点/尾结点：<code>transient Node&lt;E&gt; last;</code></p>
<p>关于Node类型我们再进入到类里看看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">COPYprivate static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先item存放的是实际数据；next指向下一个结点而prev指向上一个结点。</p>
<p>Node带参构造方法的三个参数分别是前一个结点、存储的数据、后一个结点，调用这个构造方法时将它们赋值给当前对象。</p>
<p>LinkedList是如何添加元素的呢？先看看add方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入到linkLast方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">COPYvoid linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设刚开始new了一个LinkedList对象，first和last属性都为空，调用add进入到linkLast方法。</p>
<p>首先创建一个Node变量 l 将last（此时为空）赋给它，然后new一个newNode变量存储数据，并且它的前驱指向l，后继指向null；再把last指向newNode。如下图所示：</p>
<p><img src="https://pic.downk.cc/item/5f9a62a01cd1bbb86bc58487.png" alt="img"></p>
<p>如果满足if条件，说明这是添加的第一个结点，将first指向newNode：</p>
<p><img src="https://pic.downk.cc/item/5f9a631c1cd1bbb86bc59ca6.png" alt="img"></p>
<p>至此，LinkedList对象的第一个数据添加完毕。假设需要再添加一个数据，我们可以再来走一遍，过程同上不再赘述，图示如下：</p>
<p><img src="https://pic.downk.cc/item/5f9a680e1cd1bbb86bc681f6.png" alt="img"></p>
<h3 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a><strong>ArrayList和LinkedList区别</strong></h3><p>ArrayList：必须开辟连续空间，查询快，增删慢。</p>
<p>LinkedList：无需开辟连续空间，查询慢，增删快。</p>
<p><img src="https://pic.downk.cc/item/5f9a6b371cd1bbb86bc74cda.png" alt="img"></p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Java泛型是JDK1.5中引入的一个新特性，其本质是参数化类型，把类型作为参数传递。</p>
<p>常见形式有泛型类、泛型接口、泛型方法。</p>
<p>语法：</p>
<p>&lt;T,…&gt; T称为类型占位符，表示一种引用类型。</p>
<p>好处：</p>
<p>提高代码的重用性。</p>
<p>防止类型转换异常，提高代码的安全性。</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 泛型类</span><br><span class="line"> * 语法：类名&lt;T&gt;</span><br><span class="line"> * T是类型占位符，表示一种引用类型，编写多个使用逗号隔开</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class myGeneric&lt;T&gt;&#123;</span><br><span class="line">	//1.创建泛型变量</span><br><span class="line">	//不能使用new来创建，因为泛型是不确定的类型，也可能拥有私密的构造方法。</span><br><span class="line">	T t;</span><br><span class="line">	//T t2=new T(); 泛型不能实例化 因为构造方法可能私有 可能没有无 参构造</span><br><span class="line">	//2.泛型作为方法的参数</span><br><span class="line">	public void show(T t) &#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">	&#125;</span><br><span class="line">	//泛型作为方法的返回值</span><br><span class="line">	public T getT() &#123;</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 泛型接口</span><br><span class="line"> * 语法：接口名&lt;T&gt;</span><br><span class="line"> * 注意：不能创建泛型静态常量</span><br><span class="line"> */</span><br><span class="line">public interface MyInterface&lt;T&gt; &#123;</span><br><span class="line">    //创建常量</span><br><span class="line">	String nameString=&quot;tang&quot;;</span><br><span class="line">    </span><br><span class="line">	T server(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现接口时确定泛型类</span><br><span class="line"> */</span><br><span class="line">public class MyInterfaceImpl implements MyInterface&lt;String&gt;&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public String server(String t) &#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">		return t; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//测试</span><br><span class="line">MyInterfaceImpl myInterfaceImpl=new MyInterfaceImpl();</span><br><span class="line">myInterfaceImpl.server(&quot;zhu&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现接口时不确定泛型类</span><br><span class="line"> */</span><br><span class="line">public class MyInterfaceImpl2&lt;T&gt; implements MyInterface&lt;T&gt;&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public T server(T t) &#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//测试</span><br><span class="line">MyInterfaceImpl2&lt;Integer&gt; myInterfaceImpl2=new MyInterfaceImpl2&lt;Integer&gt;();</span><br><span class="line">myInterfaceImpl2.server(2000);</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 泛型方法</span><br><span class="line"> * 语法：&lt;T&gt; 返回类型</span><br><span class="line"> */</span><br><span class="line">public class MyGenericMethod &#123;</span><br><span class="line">	public &lt;T&gt; void show(T t) &#123;</span><br><span class="line">		System.out.println(&quot;泛型方法&quot;+t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//测试</span><br><span class="line">MyGenericMethod myGenericMethod=new MyGenericMethod();</span><br><span class="line">myGenericMethod.show(&quot;tang&quot;);</span><br><span class="line">myGenericMethod.show(200);</span><br><span class="line">myGenericMethod.show(3.14);</span><br></pre></td></tr></table></figure>

<h3 id="泛型好处"><a href="#泛型好处" class="headerlink" title="泛型好处"></a>泛型好处</h3><p>提高代码重用性</p>
<p>防止类型转换异常，提高代码安全性</p>
<h3 id="泛型集合"><a href="#泛型集合" class="headerlink" title="泛型集合"></a>泛型集合</h3><ul>
<li><p><strong>概念</strong>：参数化类型、类型安全的集合，强制集合元素的类型必须一致。</p>
</li>
<li><p>特点</p>
<p>：</p>
<ul>
<li>编译时即可检查，而非运行时抛出异常。</li>
<li>访问时，不必类型转换（拆箱）。</li>
<li>不同泛型指尖引用不能相互赋值，泛型不存在多态。</li>
</ul>
</li>
</ul>
<p>之前我们在创建LinkedList类型对象的时候并没有使用泛型，但是进到它的源码中会发现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;//略&#125;</span><br></pre></td></tr></table></figure>

<p>它是一个泛型类，而我之前使用的时候并没有传递，说明java语法是允许的，这个时候传递的类型是Object类，虽然它是所有类的父类，可以存储任意的类型，但是在遍历、获取元素时需要原来的类型就要进行强制转换。这个时候就会出现一些问题，假如往链表里存储了许多不同类型的数据，在强转的时候就要判断每一个原来的类型，这样就很容易出现错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1=new ArrayList();</span><br><span class="line">arrayList1.add(&quot;223&quot;);</span><br><span class="line">//arrayList1.add(123);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Student&gt; arrayList2=new ArrayList&lt;&gt;();</span><br><span class="line">arrayList2.add(s1);</span><br></pre></td></tr></table></figure>

<p>通过泛型只能传入某一种数据，避免错误发生</p>
<h2 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h2><h3 id="set子接口"><a href="#set子接口" class="headerlink" title="set子接口"></a>set子接口</h3><ul>
<li><strong>特点</strong>：无序、无下标、元素不可重复。</li>
<li><strong>方法</strong>：全部继承自Collection中的方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void SetTest01()&#123;</span><br><span class="line">    Set&lt;String&gt; set=new HashSet&lt;String&gt;();</span><br><span class="line">    //1.添加数据</span><br><span class="line">    set.add(&quot;ming&quot;);</span><br><span class="line">    set.add(&quot;ren&quot;);</span><br><span class="line">    set.add(&quot;zuo&quot;);</span><br><span class="line">    System.out.println(&quot;数据个数：&quot;+set.size());</span><br><span class="line">    System.out.println(set.toString());//无序输出</span><br><span class="line">    //2.删除数据</span><br><span class="line">    /*</span><br><span class="line">     * set.remove(&quot;ren&quot;); System.out.println(set.toString());</span><br><span class="line">     */</span><br><span class="line">    //3.遍历【重点】</span><br><span class="line">    //3.1 使用增强for</span><br><span class="line">    for (String string : set) &#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">    //3.2 使用迭代器</span><br><span class="line">    Iterator&lt;String&gt; iterator=set.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    //4.判断</span><br><span class="line">    System.out.println(set.contains(&quot;ming&quot;));</span><br><span class="line">    System.out.println(set.isEmpty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set实现类"><a href="#set实现类" class="headerlink" title="set实现类"></a>set实现类</h3><h4 id="HashSet-重点"><a href="#HashSet-重点" class="headerlink" title="HashSet(重点)"></a>HashSet(重点)</h4><ul>
<li><p>基于HashCode计算元素存放位置。</p>
</li>
<li><p>当存入元素的哈希码相同时，会调用equals进行确认，如结果为true，则拒绝后者存入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void HashSetTest01()&#123;</span><br><span class="line">    HashSet&lt;Person&gt; hashSet=new HashSet&lt;&gt;();</span><br><span class="line">    Person p1=new Person(&quot;mi&quot;,21);</span><br><span class="line">    Person p2=new Person(&quot;ng&quot;, 22);</span><br><span class="line">    Person p3=new Person(&quot;ren&quot;, 21);</span><br><span class="line">    //1.添加元素</span><br><span class="line">    hashSet.add(p1);</span><br><span class="line">    hashSet.add(p2);</span><br><span class="line">    hashSet.add(p3);</span><br><span class="line">    //重复，添加失败</span><br><span class="line">    hashSet.add(p3);</span><br><span class="line">    //直接new一个相同属性的对象，依然会被添加，不难理解。</span><br><span class="line">    //假如相同属性便认为是同一个对象，怎么修改？</span><br><span class="line">    hashSet.add(new Person(&quot;mi&quot;, 21));</span><br><span class="line">    System.out.println(hashSet.toString());</span><br><span class="line">    //2.删除元素</span><br><span class="line">    hashSet.remove(p2);</span><br><span class="line">    //3.遍历</span><br><span class="line">    //3.1 增强for</span><br><span class="line">    for (Person person : hashSet) &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">    //3.2 迭代器</span><br><span class="line">    Iterator&lt;Person&gt; iterator=hashSet.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    //4.判断</span><br><span class="line">    System.out.println(hashSet.isEmpty());</span><br><span class="line">    //直接new一个相同属性的对象结果输出是false，不难理解。</span><br><span class="line">    //注：假如相同属性便认为是同一个对象，该怎么做？</span><br><span class="line">    System.out.println(hashSet.contains(new Person(&quot;mi&quot;, 21)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注</strong>：hashSet存储过程：</p>
<ol>
<li>根据hashCode计算保存的位置，如果位置为空，则直接保存，否则执行第二步。</li>
<li>执行equals方法，如果方法返回true，则认为是重复，拒绝存储，否则形成链表。</li>
</ol>
<p>存储过程实际上就是重复依据，要实现“注”里的问题，可以重写hashCode和equals代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    if (this == o) return true;</span><br><span class="line">    if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">    Person person = (Person) o;</span><br><span class="line">    return age == person.age &amp;&amp;</span><br><span class="line">            Objects.equals(name, person.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    return Objects.hash(name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul>
<li><p>基于排序顺序实现不重复。</p>
</li>
<li><p>实现了SortedSet接口，对集合元素自动排序。</p>
</li>
<li><p>元素对象的类型必须实现Comparable接口，指定排序规则。</p>
</li>
<li><p>通过CompareTo方法确定是否为重复元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void TreeSetTest01()&#123;</span><br><span class="line">    TreeSet&lt;Person&gt; persons=new TreeSet&lt;Person&gt;();</span><br><span class="line">    Person p1=new Person(&quot;mi&quot;,21);</span><br><span class="line">    Person p2=new Person(&quot;ng&quot;, 22);</span><br><span class="line">    Person p3=new Person(&quot;ren&quot;, 21);</span><br><span class="line">    //1.添加元素</span><br><span class="line">    persons.add(p1);</span><br><span class="line">    persons.add(p2);</span><br><span class="line">    persons.add(p3);</span><br><span class="line">    //注：直接添加会报类型转换错误，需要实现Comparable接口</span><br><span class="line">    System.out.println(persons.toString());</span><br><span class="line">    //2.删除元素</span><br><span class="line">    //persons.remove(p1);</span><br><span class="line">    persons.remove(new Person(&quot;ng&quot;, 22));</span><br><span class="line">    System.out.println(persons.toString());</span><br><span class="line">    //3.遍历（略）</span><br><span class="line">     for(Person person:persons)&#123;</span><br><span class="line">         System.out.println(person);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    Iterator iterator=persons.iterator();</span><br><span class="line">     while (iterator.hasNext())&#123;</span><br><span class="line">         System.out.println(iterator.next());</span><br><span class="line">     &#125;</span><br><span class="line">    //4.判断</span><br><span class="line">    System.out.println(persons.contains(new Person(&quot;mi&quot;, 21)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>//注：直接添加会报类型转换错误，需要实现Comparable接口</p>
<p>查看Comparable接口的源码，发现只有一个compareTo抽象方法，在人类中实现它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Person implements Comparable&lt;Person&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">	//1.先按姓名比</span><br><span class="line">	//2.再按年龄比</span><br><span class="line">	public int compareTo(Person o) &#123;</span><br><span class="line">		int n1=this.getName().compareTo(o.getName());</span><br><span class="line">		int n2=this.age-o.getAge();</span><br><span class="line">		return n1==0?n2:n1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了实现Comparable接口里的比较方法，TreeSet也提供了一个带比较器Comparator的构造方法，使用匿名内部类来实现它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Person&gt; persons=new TreeSet&lt;Person&gt;(new Comparator&lt;Person&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public int compare(Person o1, Person o2) &#123;</span><br><span class="line">				// 先按年龄比较</span><br><span class="line">				// 再按姓名比较</span><br><span class="line">				int n1=o1.getAge()-o2.getAge();</span><br><span class="line">				int n2=o1.getName().compareTo(o2.getName());</span><br><span class="line">				return n1==0?n2:n1;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;);</span><br><span class="line">		Person p1=new Person(&quot;tang&quot;,21);</span><br><span class="line">		Person p2=new Person(&quot;he&quot;, 22);</span><br><span class="line">		Person p3=new Person(&quot;yu&quot;, 21);</span><br><span class="line">		persons.add(p1);</span><br><span class="line">		persons.add(p2);</span><br><span class="line">		persons.add(p3);</span><br><span class="line">		System.out.println(persons.toString());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来做一个小案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 要求：使用TreeSet集合实现字符串按照长度进行排序</span><br><span class="line"> * helloworld tangrui hechengyang wangzixu yuguoming</span><br><span class="line"> * Comparator接口实现定制比较</span><br><span class="line"> */</span><br><span class="line">public class Demo6 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		TreeSet&lt;String&gt; treeSet=new TreeSet&lt;String&gt;(new Comparator&lt;String&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			//先比较字符串长度</span><br><span class="line">			//再比较字符串</span><br><span class="line">			public int compare(String o1, String o2) &#123;</span><br><span class="line">				int n1=o1.length()-o2.length();</span><br><span class="line">				int n2=o1.compareTo(o2);</span><br><span class="line">				return n1==0?n2:n1;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;);</span><br><span class="line">		treeSet.add(&quot;helloworld&quot;);</span><br><span class="line">		treeSet.add(&quot;tangrui&quot;);</span><br><span class="line">		treeSet.add(&quot;hechenyang&quot;);</span><br><span class="line">		treeSet.add(&quot;yuguoming&quot;);</span><br><span class="line">		treeSet.add(&quot;wangzixu&quot;);</span><br><span class="line">		System.out.println(treeSet.toString());</span><br><span class="line">        //输出[tangrui, wangzixu, yuguoming, hechenyang, helloworld]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><ul>
<li><p><strong>特点</strong>：存储一对数据（Key-Value），无序、无下标，键不可重复。</p>
</li>
<li><p><strong>方法</strong>：</p>
<p>V put(K key,V value)//将对象存入到集合中，关联键值。key重复则覆盖原值。</p>
</li>
<li><p>Object get(Object key)//根据键获取相应的值。</p>
<p>Set<K>//返回所有的key</K></p>
<p>Collection<V> values()//返回包含所有值的Collection集合。</V></p>
<p>Set&lt;Map.Entry&lt;K,V&gt;&gt;//键值匹配的set集合</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void MapTest01()&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map=new HashMap&lt;String, Integer&gt;();</span><br><span class="line">        //1.添加元素</span><br><span class="line">        map.put(&quot;mi&quot;, 21);</span><br><span class="line">        map.put(&quot;ng&quot;, 22);</span><br><span class="line">        map.put(&quot;ren&quot;, 23);</span><br><span class="line">        map.put(&quot;mi&quot;, 25);        //覆盖第一个</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        //2.删除元素</span><br><span class="line">        map.remove(&quot;ng&quot;);</span><br><span class="line">        System.out.println(map.toString());</span><br><span class="line">        //3.遍历</span><br><span class="line">        //3.1 使用keySet();</span><br><span class="line">        for (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key+&quot; &quot;+map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        //3.2 使用entrySet();效率较高</span><br><span class="line">        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey()+&quot; &quot;+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map实现类"><a href="#Map实现类" class="headerlink" title="Map实现类"></a>Map实现类</h3><h4 id="HashMap-重点"><a href="#HashMap-重点" class="headerlink" title="HashMap(重点)"></a>HashMap(重点)</h4><p>JDK1.2版本，线程不安全，运行效率快；允许用null作为key或是value。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void HashMapTest01()&#123;</span><br><span class="line">    HashMap&lt;Student, String&gt; hashMap=new HashMap&lt;Student, String&gt;();</span><br><span class="line">    Student s1=new Student(&quot;mi&quot;, 36);</span><br><span class="line">    Student s2=new Student(&quot;ng&quot;, 101);</span><br><span class="line">    Student s3=new Student(&quot;ren&quot;, 10);</span><br><span class="line">    //1.添加元素</span><br><span class="line">    hashMap.put(s1, &quot;成都&quot;);</span><br><span class="line">    hashMap.put(s2, &quot;杭州&quot;);</span><br><span class="line">    hashMap.put(s3, &quot;郑州&quot;);</span><br><span class="line">    //添加失败，但会更新值</span><br><span class="line">    hashMap.put(s3,&quot;上海&quot;);</span><br><span class="line">    //添加成功，不过两个属性一模一样；</span><br><span class="line">    //注：假如相同属性便认为是同一个对象，怎样修改？</span><br><span class="line">    hashMap.put(new Student(&quot;ren&quot;, 10),&quot;上海&quot;);</span><br><span class="line">    System.out.println(hashMap.toString());</span><br><span class="line">    //2.删除元素</span><br><span class="line">    hashMap.remove(s3);</span><br><span class="line">    System.out.println(hashMap.toString());</span><br><span class="line">    //3.遍历</span><br><span class="line">    //3.1 使用keySet()遍历</span><br><span class="line">    for (Student key : hashMap.keySet()) &#123;</span><br><span class="line">        System.out.println(key+&quot; &quot;+hashMap.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    //3.2 使用entrySet()遍历</span><br><span class="line">    for (Map.Entry&lt;Student, String&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">        System.out.println(entry.getKey()+&quot; &quot;+entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    //4.判断</span><br><span class="line">    //注：同上</span><br><span class="line">    System.out.println(hashMap.containsKey(new Student(&quot;he&quot;, 10)));</span><br><span class="line">    System.out.println(hashMap.containsValue(&quot;成都&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：和之前说过的HashSet类似，重复依据是hashCode和equals方法，重写即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public int hashCode() &#123;</span><br><span class="line">      final int prime = 31;</span><br><span class="line">      int result = 1;</span><br><span class="line">      result = prime * result + id;</span><br><span class="line">      result = prime * result + ((name == null) ? 0 : name.hashCode());</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean equals(Object obj) &#123;</span><br><span class="line">      if (this == obj)</span><br><span class="line">          return true;</span><br><span class="line">      if (obj == null)</span><br><span class="line">          return false;</span><br><span class="line">      if (getClass() != obj.getClass())</span><br><span class="line">          return false;</span><br><span class="line">      Student other = (Student) obj;</span><br><span class="line">      if (id != other.id)</span><br><span class="line">          return false;</span><br><span class="line">      if (name == null) &#123;</span><br><span class="line">          if (other.name != null)</span><br><span class="line">              return false;</span><br><span class="line">      &#125; else if (!name.equals(other.name))</span><br><span class="line">          return false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a><strong>HashMap源码分析</strong></h4></li>
<li><p>默认初始化容量：<code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</code></p>
<ul>
<li>数组最大容量：<code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code></li>
</ul>
</li>
<li><p>默认加载因子：<code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></p>
</li>
<li><p>链表调整为红黑树的链表长度阈值（JDK1.8）：<code>static final int TREEIFY_THRESHOLD = 8;</code></p>
</li>
<li><p>红黑树调整为链表的链表长度阈值（JDK1.8）：<code>static final int UNTREEIFY_THRESHOLD = 6;</code></p>
</li>
<li><p>链表调整为红黑树的数组最小阈值（JDK1.8）：<code>static final int MIN_TREEIFY_CAPACITY = 64;</code></p>
</li>
<li><p>HashMap存储的数组：<code>transient Node&lt;K,V&gt;[] table;</code></p>
</li>
<li><p>HashMap存储的元素个数：<code>transient int size;</code></p>
<blockquote>
<ul>
<li>默认加载因子是什么？<ul>
<li>就是判断数组是否扩容的一个因子。假如数组容量为100，如果HashMap的存储元素个数超过了100*0.75=75，那么就会进行扩容。</li>
</ul>
</li>
<li>链表调整为红黑树的链表长度阈值是什么？<ul>
<li>假设在数组中下标为3的位置已经存储了数据，当新增数据时通过哈希码得到的存储位置又是3，那么就会在该位置形成一个链表，当链表过长时就会转换成红黑树以提高执行效率，这个阈值就是链表转换成红黑树的最短链表长度；</li>
</ul>
</li>
<li>红黑树调整为链表的链表长度阈值是什么？<ul>
<li>当红黑树的元素个数小于该阈值时就会转换成链表。</li>
</ul>
</li>
<li>链表调整为红黑树的数组最小阈值是什么？<ul>
<li>并不是只要链表长度大于8就可以转换成红黑树，在前者条件成立的情况下，数组的容量必须大于等于64才会进行转换。</li>
</ul>
</li>
</ul>
</blockquote>
<p>HashMap的数组table存储的就是一个个的Node&lt;K,V&gt;类型，很清晰地看到有一对键值，还有一个指向next的指针（以下只截取了部分源码）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COPYstatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">      final K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>之前的代码中在new对象时调用的是HashMap的无参构造方法，进入到该构造方法的源码查看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic HashMap() &#123;</span><br><span class="line">      this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>发现没什么内容，只是赋值了一个默认加载因子；而在上文我们观察到源码中table和size都没有赋予初始值，说明刚创建的HashMap对象没有分配容量，并不拥有默认的16个空间大小，这样做的目的是为了节约空间，此时table为null，size为0。</p>
<p>当我们往对象里添加元素时调用put方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic V put(K key, V value) &#123;</span><br><span class="line">      return putVal(hash(key), key, value, false, true);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>put方法把key和value传给了putVal，同时还传入了一个hash(Key)所返回的值，这是一个产生哈希值的方法，再进入到putVal方法（部分源码）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">COPYfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                    boolean evict) &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">      if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">      if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">          tab[i] = newNode(hash, key, value, null);</span><br><span class="line">      else&#123;</span><br><span class="line">          //略</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里面创建了一个tab数组和一个Node变量p，第一个if实际是判断table是否为空，而我们现在只关注刚创建HashMap对象时的状态，此时tab和table都为空，满足条件，执行内部代码，这条代码其实就是把resize()所返回的结果赋给tab，n就是tab的长度，resize顾名思义就是重新调整大小。查看resize()源码（部分）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">COPYfinal Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">      int oldThr = threshold;</span><br><span class="line">      if (oldCap &gt; 0);</span><br><span class="line">      else if (oldThr &gt; 0);</span><br><span class="line">      else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125; </span><br><span class="line">      @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      return newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>该方法首先把table及其长度赋值给oldTab和oldCap；threshold是阈值的意思，此时为0，所以前两个if先不管，最后else里newCap的值为默认初始化容量16；往下创建了一个newCap大小的数组并将其赋给了table，刚创建的HashMap对象就在这里获得了初始容量。然后我们再回到putVal方法，第二个if就是根据哈希码得到的tab中的一个位置是否为空，为空便直接添加元素，此时数组中无元素所以直接添加。至此HashMap对象就完成了第一个元素的添加。当添加的元素超过16*0.75=12时，就会进行扩容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COPYfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)&#123;</span><br><span class="line">      if (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>扩容的代码如下（部分）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">COPYfinal Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">      int newCap;</span><br><span class="line">      if (oldCap &gt; 0) &#123;</span><br><span class="line">          if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//略&#125;</span><br><span class="line">          else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>核心部分是else if里的移位操作，<strong>也就是说每次扩容都是原来大小的两倍</strong>。</p>
</li>
<li><p>*注**：额外说明的一点是在JDK1.8以前链表是头插入，JDK1.8以后链表是尾插入。</p>
</li>
</ul>
<hr>
<h4 id="HashSet源码分析"><a href="#HashSet源码分析" class="headerlink" title="HashSet源码分析"></a><strong>HashSet源码分析</strong></h4><p>了解完HashMap之后，再回过头来看之前的HashSet源码，为什么放在后面写你们看一下源码就知道了（部分）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic class HashSet&lt;E&gt;</span><br><span class="line">      extends AbstractSet&lt;E&gt;</span><br><span class="line">      implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">  &#123;</span><br><span class="line">      private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">      private static final Object PRESENT = new Object();</span><br><span class="line">      public HashSet() &#123;</span><br><span class="line">          map = new HashMap&lt;&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看见HashSet的存储结构就是HashMap，那它的存储方式是怎样的呢？可以看一下add方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic boolean add(E e) &#123;</span><br><span class="line">      return map.put(e, PRESENT)==null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>很明了地发现它的add方法调用的就是map的put方法，把元素作为map的key传进去的。。</p>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a><strong>Hashtable</strong></h4><ul>
<li><p>JDK1.0版本，线程安全，运行效率慢；不允许null作为key或是value。</p>
</li>
<li><p>初始容量11，加载因子0.75。</p>
<p>这个集合在开发过程中已经不用了，稍微了解即可。</p>
</li>
</ul>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a><strong>Properties</strong></h4><ul>
<li>Hashtable的子类，要求key和value都是String。通常用于配置文件的读取。</li>
</ul>
<p>它继承了Hashtable的方法，与流关系密切，此处不详解。</p>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>实现了SortedMap接口（是Map的子接口），可以对key自动排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Student, Integer&gt; treeMap=new TreeMap&lt;Student, Integer&gt;();</span><br><span class="line">		Student s1=new Student(&quot;tang&quot;, 36);</span><br><span class="line">		Student s2=new Student(&quot;yu&quot;, 101);</span><br><span class="line">		Student s3=new Student(&quot;he&quot;, 10);</span><br><span class="line">		//1.添加元素</span><br><span class="line">		treeMap.put(s1, 21);</span><br><span class="line">		treeMap.put(s2, 22);</span><br><span class="line">		treeMap.put(s3, 21);</span><br><span class="line">		//不能直接打印，需要实现Comparable接口，因为红黑树需要比较大小</span><br><span class="line">		System.out.println(treeMap.toString());</span><br><span class="line">		//2.删除元素</span><br><span class="line">		treeMap.remove(new Student(&quot;he&quot;, 10));</span><br><span class="line">		System.out.println(treeMap.toString());</span><br><span class="line">		//3.遍历</span><br><span class="line">		//3.1 使用keySet()</span><br><span class="line">		for (Student key : treeMap.keySet()) &#123;</span><br><span class="line">			System.out.println(key+&quot; &quot;+treeMap.get(key));</span><br><span class="line">		&#125;</span><br><span class="line">		//3.2 使用entrySet()</span><br><span class="line">		for (Entry&lt;Student, Integer&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">			System.out.println(entry.getKey()+&quot; &quot;+entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">		//4.判断</span><br><span class="line">		System.out.println(treeMap.containsKey(s1));</span><br><span class="line">		System.out.println(treeMap.isEmpty());		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在学生类中实现Comparable接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Comparable&lt;Student&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Student o) &#123;</span><br><span class="line">        int n1=this.id-o.id;</span><br><span class="line">        return n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外还可以使用比较器来定制比较：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Student, Integer&gt; treeMap2=new TreeMap&lt;Student, Integer&gt;(new Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Student o1, Student o2) &#123;</span><br><span class="line">        // 略</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;			</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="TreeSet源码"><a href="#TreeSet源码" class="headerlink" title="TreeSet源码"></a><strong>TreeSet源码</strong></h4><p>和HashSet类似，放在TreeMap之后讲便一目了然（部分）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;</span><br><span class="line">    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    private transient NavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    private static final Object PRESENT = new Object();</span><br><span class="line">    TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">        this.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeSet() &#123;</span><br><span class="line">        this(new TreeMap&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeSet的存储结构实际上就是TreeMap，再来看其存储方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPYpublic boolean add(E e) &#123;</span><br><span class="line">    return m.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的add方法调用的就是TreeMap的put方法，将元素作为key传入到存储结构中。</p>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a><strong>Collections工具类</strong></h2><ul>
<li><p><strong>概念</strong>：集合工具类，定义了除了存取以外的集合常用方法。</p>
</li>
<li><p><strong>方法</strong>：</p>
<p>public static void reverse(List&lt;?&gt; list)//反转集合中元素的顺序</p>
<p>public static void shuffle(List&lt;?&gt; list)//随机重置集合元素的顺序</p>
<p>public static void sort(List<T> list)//升序排序（元素类型必须实现Comparable接口）</T></p>
</li>
</ul>
<p>List<Integer> list=new ArrayList<Integer>();<br>        list.add(20);<br>        list.add(10);<br>        list.add(30);<br>        list.add(90);<br>        list.add(70);</Integer></Integer></p>
<pre><code>    //sort排序
    System.out.println(list.toString());
    Collections.sort(list);
    System.out.println(list.toString());
    System.out.println(&quot;---------&quot;);
    
    //binarySearch二分查找
    int i=Collections.binarySearch(list, 10);
    System.out.println(i);
    
    //copy复制
    List&lt;Integer&gt; list2=new ArrayList&lt;Integer&gt;();
    for(int i1=0;i1&lt;5;++i1) &#123;
        list2.add(0);
    &#125;
    //该方法要求目标元素容量大于等于源目标
    Collections.copy(list2, list);
    System.out.println(list2.toString());
    
    //reserve反转
    Collections.reverse(list2);
    System.out.println(list2.toString());
    
    //shuffle 打乱
    Collections.shuffle(list2);
    System.out.println(list2.toString());
    
    //补充：list转成数组
    Integer[] arr=list.toArray(new Integer[0]);
    System.out.println(arr.length);
    //补充：数组转成集合 
    String[] nameStrings= &#123;&quot;tang&quot;,&quot;he&quot;,&quot;yu&quot;&#125;;
    //受限集合，不能添加和删除
    List&lt;String&gt; list3=Arrays.asList(nameStrings);
    System.out.println(list3);
    
    //注：基本类型转成集合时需要修改为包装类
&#125;
</code></pre>

      
      
        <div class="page-reward">
          <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang">赏</a></p>
          <div class="hide_box"></div>
          <div class="shang_box">
            <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()">×</a>
            <div class="shang_tit">
              <p></p>
            </div>
            <div class="shang_payimg">
              <img src="/img/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
            </div>
              <div class="pay_explain">扫码打赏</div>
            <div class="shang_payselect">
              
                <div class="pay_item checked" data-id="alipay">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/zfbzf.png" alt="支付宝" /></span>
                </div>
              
              
                <div class="pay_item" data-id="wechat">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/wxzf.png" alt="微信" /></span>
                </div>
              
            </div>
            <div class="shang_info">
              <p>打开<span id="shang_pay_txt">支付宝</span>扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
        <script type="text/javascript">
          $(".pay_item").click(function(){
            $(this).addClass('checked').siblings('.pay_item').removeClass('checked');
            var dataid=$(this).attr('data-id');
            $(".shang_payimg img").attr("src","/img/"+dataid+"img.jpg");
            $("#shang_pay_txt").text(dataid=="alipay"?"支付宝":"微信");
          });
          function dashangToggle(){
            
            $(".hide_box").fadeToggle();
            $(".shang_box").fadeToggle();
          }
        </script>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2021/05/14/%E9%9B%86%E5%90%88/">集合</a></p>
        <p><span>文章作者:</span><a href="/" title="访问  的个人博客"></a></p>
        <p><span>发布时间:</span>2021年05月14日 - 18时19分</p>
        <p><span>最后更新:</span>2021年05月14日 - 18时21分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2021/05/14/%E9%9B%86%E5%90%88/" title="集合">https://mingren1314.github.io/2021/05/14/%E9%9B%86%E5%90%88/</a>
            <span class="copy-path" data-clipboard-text="原文: https://mingren1314.github.io/2021/05/14/%E9%9B%86%E5%90%88/　　作者: " title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2021/05/14/%E5%8F%8D%E5%B0%84/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          反射
        
      </div>
    </a>
  
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E5%90%88"><span class="toc-number">1.1.</span> <span class="toc-text">什么是集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E4%BD%93%E7%B3%BB%E9%9B%86%E5%90%88"><span class="toc-number">1.2.</span> <span class="toc-text">Collection体系集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E7%88%B6%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.</span> <span class="toc-text">Collection父接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A81"><span class="toc-number">1.3.1.</span> <span class="toc-text">Collection接口的使用1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A82"><span class="toc-number">1.3.2.</span> <span class="toc-text">Collection接口的使用2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E7%94%9F%E7%B1%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">学生类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E5%AD%90%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.</span> <span class="toc-text">Collection子接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E9%9B%86%E5%90%88"><span class="toc-number">1.4.1.</span> <span class="toc-text">List集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A81"><span class="toc-number">1.4.2.</span> <span class="toc-text">List集合的使用1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A82"><span class="toc-number">1.4.3.</span> <span class="toc-text">List集合的使用2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">1.4.4.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.4.5.</span> <span class="toc-text">ArrayL源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector"><span class="toc-number">1.4.6.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList"><span class="toc-number">1.4.7.</span> <span class="toc-text">LinkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.4.8.</span> <span class="toc-text">LinkedList源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.9.</span> <span class="toc-text">ArrayList和LinkedList区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">1.5.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.3.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%A5%BD%E5%A4%84"><span class="toc-number">1.5.5.</span> <span class="toc-text">泛型好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88"><span class="toc-number">1.5.6.</span> <span class="toc-text">泛型集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set%E9%9B%86%E5%90%88"><span class="toc-number">1.6.</span> <span class="toc-text">set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E5%AD%90%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.1.</span> <span class="toc-text">set子接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.6.2.</span> <span class="toc-text">set实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet-%E9%87%8D%E7%82%B9"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">HashSet(重点)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">TreeSet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-number">1.7.</span> <span class="toc-text">Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.7.1.</span> <span class="toc-text">Map实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E9%87%8D%E7%82%B9"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">HashMap(重点)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">HashMap源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">HashSet源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hashtable"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">Hashtable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">Properties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap"><span class="toc-number">1.7.1.6.</span> <span class="toc-text">TreeMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet%E6%BA%90%E7%A0%81"><span class="toc-number">1.7.1.7.</span> <span class="toc-text">TreeSet源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.8.</span> <span class="toc-text">Collections工具类</span></a></li></ol></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">


<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'swing'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>
    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2021/05/14/%E5%8F%8D%E5%B0%84/" title="上一篇: 反射">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/18/vue%E5%9F%BA%E7%A1%80/">vue基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/18/jdbc/">jdbc</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/scanf%E9%97%AE%E9%A2%98/">scanf问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/">进制转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">自定义数据类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/">文件操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/%E6%8C%87%E9%92%88%E9%9D%A2%E8%AF%95%E9%A2%98/">指针面试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/%E8%BF%9B%E9%98%B6%E6%8C%87%E9%92%88/">进阶指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/%E5%88%9D%E7%BA%A7%E6%8C%87%E9%92%88/">初级指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/%E5%88%9D%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">初级数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">进阶数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/javaweb%E5%9F%BA%E7%A1%80/">javaweb基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E5%8F%8D%E5%B0%84/">反射</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E9%9B%86%E5%90%88/">集合</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2021 mingr
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="http://bestwing.me" target="_blank">Sw'blog</a> by Swing
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >海贼到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


    <script type="text/javascript">
      window.onload = function(){
        document.getElementById("search").onclick = function(){
            console.log("search")
            search();
        }
      }
      function search(){
        (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
        (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
        e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
        })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

        _st('install','A1Pz-LKMXbrzcFg2FWi6','2.0.0');
      }
    </script>

  </div>
</body>
</html>