<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="title: 进阶数据结构date: 2021-05-14 18:19:10tags: 进阶数据结构树树的概念 树是一种非线性的数据结构，它是由n（n&gt;&#x3D;0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。  树的特点 每个结点有零个或多个子节点 每一个非根结点有且只有一个父节点 只有根节点没有父节点 除了根结点外，每个子节点可以">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://mingren1314.github.io/2021/05/14/%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="title: 进阶数据结构date: 2021-05-14 18:19:10tags: 进阶数据结构树树的概念 树是一种非线性的数据结构，它是由n（n&gt;&#x3D;0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。  树的特点 每个结点有零个或多个子节点 每一个非根结点有且只有一个父节点 只有根节点没有父节点 除了根结点外，每个子节点可以">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209181508731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021020918152054.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209181526952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209181533515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdn.net/20171209154316971?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1Ym9rZTMzNDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20171209154723845?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1Ym9rZTMzNDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20171209154852594?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1Ym9rZTMzNDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190817141447986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlbGxvd2QxMjM=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190817141613195.png">
<meta property="og:image" content="https://img-blog.csdn.net/20171209161606584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1Ym9rZTMzNDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20171209161838340?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1Ym9rZTMzNDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20171209161937128?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1Ym9rZTMzNDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20180704200305280?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODQwMTI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019050314171360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VlYmFpY2Fp,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180216664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180245259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021020918030618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180321138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180335482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021020918034986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180359163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180407103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180417690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180426174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180436678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180446155.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180454181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180501627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180510647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180519280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021020918052847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180539472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180601855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180646435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180704767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180712527.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180720602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180729608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180745584.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180754418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021020918080567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180813604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180824159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180833971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180842925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180852436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180901648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210209180911241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdn.net/20170225164106193?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225164347019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225165023103?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225170217312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225170847003?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225200642225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225200807038?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225200819460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226103426439?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226104025425?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226104838359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226144656132?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226144714468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226164845621?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226171332169?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226171617219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170227144216870?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170227151046657?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170227155439125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225164106193?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225164347019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225165023103?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225170217312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225170847003?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225200642225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225200807038?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170225200819460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226103426439?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226104025425?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226104838359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226144656132?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226144714468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226164845621?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226171332169?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170226171617219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170227144216870?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170227151046657?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170227155439125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="article:published_time" content="2021-05-14T15:24:45.900Z">
<meta property="article:modified_time" content="2021-05-14T15:30:43.732Z">
<meta property="article:author" content="mingr">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20210209181508731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="//img/tx.jpg">
  
  
      
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true
      }
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/tx.jpg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives">文章归档</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="https://github.com/mingren1314" title="github">github</a>
                            
                                <a class="fl QQ"  target="_blank" href="http://wpa.qq.com/msgrd?v=3&uin=2674672641&site=qq&menu=yes" title="QQ">QQ</a>
                            
                                <a class="fl wechat"  target="_blank" href="/img/wx.jpg" title="wechat">wechat</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://ring3.xyz/">Yllen</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://mxny.org/">麦香浓郁</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://whereisk0shl.top/">K0sh1</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.ycjcl.cc/">信鑫</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://bystudent.com/">ByStundet表哥</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.jarviswang.me/">汪神_Jarvis</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://sh3ll.me/">Chu</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.hackfun.org/">4ido10n</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/iamstudy">L3m0n</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://o0xmuhe.me/">muhe</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.nuptzj.cn/">_画船听雨</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.virzz.com/index.html">Virink</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.sqlsec.com/">国光</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.bodkin.ren/">老锥</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cizel.cn/">C1zel</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://1phan.cc">1phan</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.liuil.top/">liuil</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/Ox9A82/">Ox9A82</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://burnegg.com/">burnegg</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://jwrsec.cn/">jwr-sec</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://sudalover.cn/">苏打</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.binklac.com">VeroFess</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.bendawang.site/">bendawang</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://weeklyalgo.codes/">hook</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.flier.net.cn/">Flier&#39;blog</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.mutepig.club">mutepig</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://blog.iret.xyz/list.aspx">Silver</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://simp1e.leanote.com/">Simple</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://processor.pub/">Processor</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">性别男 爱好女</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="//img/tx.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives">文章归档</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="https://github.com/mingren1314" title="github">github</a>
                    
                        <a class="QQ" target="_blank" href="http://wpa.qq.com/msgrd?v=3&uin=2674672641&site=qq&menu=yes" title="QQ">QQ</a>
                    
                        <a class="wechat" target="_blank" href="/img/wx.jpg" title="wechat">wechat</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-进阶数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/05/14/%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
      <time datetime="2021-05-14T15:24:45.900Z" itemprop="datePublished">2021-05-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>title: 进阶数据结构<br>date: 2021-05-14 18:19:10<br>tags:</p>
<h1 id="进阶数据结构"><a href="#进阶数据结构" class="headerlink" title="进阶数据结构"></a>进阶数据结构</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h3><p> 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。 </p>
<h3 id="树的特点"><a href="#树的特点" class="headerlink" title="树的特点"></a>树的特点</h3><ul>
<li>每个结点有零个或多个子节点</li>
<li>每一个非根结点有且只有一个父节点</li>
<li>只有根节点没有父节点</li>
<li>除了根结点外，每个子节点可以分为多个不相交的子树叶子节点</li>
</ul>
<h3 id="树的相关定义"><a href="#树的相关定义" class="headerlink" title="树的相关定义"></a>树的相关定义</h3><p><img src="https://img-blog.csdnimg.cn/20210209181508731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3d723Nxy-1612864710794)(1.png)]"></p>
<p> 如上图所示<br><strong>节点的度：</strong> 一个节点含有的子树的个数称为该节点的度； 如上图：A的为6<br><strong>叶节点或终端节点：</strong> 度为0的节点称为叶节点； 如上图：B、C、H、I…等节点为叶节点<br><strong>非终端节点或分支节点：</strong> 度不为0的节点； 如上图：D、E、F、G…等节点为分支节点<br><strong>双亲节点或父节点：</strong> 若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点<br><strong>孩子节点或子节点：</strong> 一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点<br><strong>兄弟节点：</strong> 具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点<br><strong>树的度：</strong> 一棵树中，最大的节点的度称为树的度； 如上图：树的度为6<br><strong>节点的层次：</strong> 从根开始定义起，根为第1层，根的子节点为第2层，以此类推<br><strong>树的高度或深度：</strong> 树中节点的最大层次； 如上图：树的高度为4<br><strong>堂兄弟节点：</strong> 双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点<br><strong>节点的祖先：</strong> 从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先<br><strong>子孙：</strong> 以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙<br><strong>森林：</strong> 由m（m&gt;0）棵互不相交的树的集合称为森林 </p>
<h3 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h3><ul>
<li><p>表示一棵树：主要是找节点、节点之间的关系。</p>
</li>
<li><p>表示方式：双亲表示法、孩子表示法、孩子兄弟表示法等</p>
<p><img src="https://img-blog.csdnimg.cn/2021020918152054.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kOrvxrT9-1612864710795)(2.png)]"></p>
</li>
</ul>
<p>  <img src="https://img-blog.csdnimg.cn/20210209181526952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OHvpxc2s-1612864710797)(3.png)]"></p>
<p>  <img src="https://img-blog.csdnimg.cn/20210209181533515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fZMhq7TT-1612864710800)(4.png)]"></p>
<ul>
<li>双亲表示法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">int data;//当前节点的值域</span><br><span class="line">struct Node* parent;//当前节点的双亲位置</span><br><span class="line">&#125;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<ul>
<li>孩子表示法:孩子给几个主要取决于树的度是多少。<br>假设这棵树的度为2。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">int data;</span><br><span class="line">struct Node* child1;</span><br><span class="line">struct Node* child2;</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<ul>
<li>孩子兄弟表示法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">	struct Node* child;</span><br><span class="line">	struct Node* brother;</span><br><span class="line">	int data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树基本概念"><a href="#二叉树基本概念" class="headerlink" title="二叉树基本概念"></a>二叉树基本概念</h2><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>一棵二叉树是节点的一个有限集合，该集合或者为空，或者由一个根节点加上两棵左子树和右子树组成</p>
<h3 id="二叉树的特点："><a href="#二叉树的特点：" class="headerlink" title="二叉树的特点："></a>二叉树的特点：</h3><p>1、每个节点最多有两棵子树，即二叉树不存在度大于2的节点</p>
<p>2、二叉树的子树有左右之分，其子树的次序不能颠倒</p>
<h3 id="二叉树的形式："><a href="#二叉树的形式：" class="headerlink" title="二叉树的形式："></a>二叉树的形式：</h3><p><img src="https://img-blog.csdn.net/20171209154316971?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1Ym9rZTMzNDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h3 id="满二叉树："><a href="#满二叉树：" class="headerlink" title="满二叉树："></a>满二叉树：</h3><p>在一棵二叉树中，所有分支节点都存在左子树和右子树，并且所有的叶节点都在同一层上</p>
<p><img src="https://img-blog.csdn.net/20171209154723845?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1Ym9rZTMzNDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h3 id="完全二叉树："><a href="#完全二叉树：" class="headerlink" title="完全二叉树："></a>完全二叉树：</h3><p> 完全二叉树是由满二叉树而引出来的，若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数(即1~h-1层为一个满二叉树)，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树 </p>
<p><img src="https://img-blog.csdn.net/20171209154852594?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1Ym9rZTMzNDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h3 id="扩充二叉树"><a href="#扩充二叉树" class="headerlink" title="扩充二叉树"></a>扩充二叉树</h3><p> 扩充二叉树是对已有二叉树的扩充，扩充后的二叉树的节点都变为度数为2的分支节点。也就是说，如果原节点的度数为2，则不变，度数为1，则增加一个分支，度数为0的叶子节点则增加两个分支。<br><img src="https://img-blog.csdnimg.cn/20190817141447986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlbGxvd2QxMjM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>是一棵空树或它的任意节点的左右两个子树的高度差的绝对值不超过1<br><img src="https://img-blog.csdnimg.cn/20190817141613195.png" alt="在这里插入图片描述"></p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>如果某个结点的左孩子为空,则将空的左孩子指针域改为指向其前驱;如果某结点的右孩子为空,则将空的右孩子指针域改为指向其后继.另外应再多创建一个不存储数据的结点,供没有后继的结点指.</p>
<h3 id="二叉树的性质："><a href="#二叉树的性质：" class="headerlink" title="二叉树的性质："></a>二叉树的性质：</h3><p>1、若规定根节点的层数为1，则一棵非空二叉树的第i层上最多有2i-1个节点</p>
<p>2、若规定只有根节点的二叉树的深度为1，则深度为k的二叉树的最大节点数是2^k-1</p>
<p>3、对任何一棵二叉树，如果其叶子节点个数为n0，度为2的非叶子节点个数为n2，则n0=n2+1</p>
<p>4、具有n个节点的完全二叉树的深度k为log2(n+1)向上取整</p>
<p>5、对于具有n个节点的完全二叉树，如果按照从上至下从左至右的顺序对所有结点从0开始编号，则对于序号为i的节点有：</p>
<p>（1）如果i&gt;=0，则序号为i节点的双亲结点的序号为（i-1）/2；如果i=0，则序号i节点无双亲结点</p>
<p>（2）如果2i+1&lt;n，则序号i结点的左孩子的序号为2i+1，右孩子的序号为2i+2；如果2i+1&gt;=n，则序号i节点无孩子节点</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p><img src="https://img-blog.csdn.net/20171209161606584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1Ym9rZTMzNDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>优点：存储完全二叉树，简单省空间</p>
<p>缺点：对一般二叉树尤其单支树，存储空间利用不理想</p>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p><img src="https://img-blog.csdn.net/20171209161838340?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1Ym9rZTMzNDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h4 id="仿真指针存储"><a href="#仿真指针存储" class="headerlink" title="仿真指针存储"></a>仿真指针存储</h4><p><img src="https://img-blog.csdn.net/20171209161937128?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1Ym9rZTMzNDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h3 id="二叉树的应用场景"><a href="#二叉树的应用场景" class="headerlink" title="二叉树的应用场景"></a>二叉树的应用场景</h3><ul>
<li>普通的二叉树，很难构成现实的应用场景，但因其简单，常用于学习研究，平衡二叉树则是实际应用比较多的。常见于快速匹配、搜索等方面。</li>
<li>常用的树有：AVL树、红黑树、B+树、Trie（字典）树。<br>1、AVL树: 最早的平衡二叉树之一。应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL树。<br>2、红黑树: 平衡二叉树，广泛用在C++的STL中。如map和set都是用红黑树实现的。还有Linux文件管理。<br>3、B/B+树: 用在磁盘文件组织 数据索引和数据库索引。<br>4、Trie树(字典树): 用在统计和排序大量字符串，如自动机、M数据库索引。</li>
</ul>
<h2 id="二叉树的操作"><a href="#二叉树的操作" class="headerlink" title="二叉树的操作"></a>二叉树的操作</h2><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p> 二叉树的遍历主要有三种：</p>
<p>1.前序遍历（根-&gt;左-&gt;右）</p>
<p>2.中序遍历（左-&gt;根-&gt;右）</p>
<p>3.后序遍历（左-&gt;右-&gt;根）</p>
<p>举例分析这三种情况  如下图：</p>
<p> <img src="https://img-blog.csdn.net/20180704200305280?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODQwMTI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"> </p>
<h4 id="前序遍历："><a href="#前序遍历：" class="headerlink" title="前序遍历："></a>前序遍历：</h4><p>每遍历一个结点，都要当作一个根对待，对这个根进行前序遍历，比如这个二叉树，从A结点开始（此时A结点是一个根，根-&gt;左-&gt;右），然后左，也就是B，再把B当作一个根（根-&gt;左-&gt;右），所以下面是D，再把B当作一个根（根-&gt;左-&gt;右），没有左，所以再右，也就是H，H没有子树了，然后再遍历B的右，也就是E，再把E当作一个根，没有左，所以右，也就是I，I没有子树了，再遍历A的右，也就是C，此时完成的遍历顺序是（<strong>A-&gt;B-&gt;D-&gt;H-&gt;E-&gt;I-&gt;C</strong>）,遍历完A结点的左子树了，再遍历右，也就是C，把C当作一个根（根-&gt;左-&gt;右），左也就是F，再把F当成一个根（根-&gt;左-&gt;右），左就是J，右就是K，然后J和K都没有子树，就回去遍历C的右，也就是G，G也没有子树，此时A的右子树就遍历完了，所以这个二叉树就遍历完了，遍历完成的顺序是（<strong>A-&gt;B-&gt;D-&gt;H-&gt;E-&gt;I-&gt;C-&gt;F-&gt;J-&gt;K-&gt;G</strong>）</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>因为中序遍历是左-&gt;根-&gt;右，所以从A结点开始的时候，先遍历B，然后把B当作一个根，再遍历B的左，就是D，然后把D当作一个根，遍历D的左，D没有左子树，所以遍历D，然后右，也就是H，然后回去遍历B，再遍历他的右，也就是E，再把E当作一个根，遍历E的左，没有左，遍历E，再遍历右，也就是I，然后A的左子树都遍历完成，回去遍历A，此时遍历的顺序是（<strong>D-&gt;H-&gt;B-&gt;E-&gt;I-&gt;A</strong>），A的左子树遍历完成后，再遍历A的右子树，首先是C，然后把C当作一个根，遍历他的左，也就是F，然后把F当作一个根，遍历他的左，也就是J，然后J没有子树，回去遍历根F后，再遍历右，也就是K，K也没有子树，所以C的左子树遍历完了，再遍历C后，遍历右，也就是G，此时G没有子树，所以A的右子树遍历完了，所以这个二叉树就遍历完了，遍历完成的顺序是（<strong>D-&gt;H-&gt;B-&gt;E-&gt;I-&gt;A-&gt;J-&gt;F-&gt;K-&gt;C-&gt;G</strong>）</p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>因为后序遍历是左-&gt;右-&gt;根，所以从A结点开始时，先遍历左，也就是B，然后把B当作一个根，再遍历他的左，也就是D，然后把D当作一个根，他没有左子树，所以再遍历他的右，也就是H，然后回去遍历根，也就是D，然后再回去遍历B的右，也就是E，把E当作一个根，E没有左子树，所以遍历他的右，也就是I，然后回去遍历根E，然后再回去遍历根B，此时A的左子树遍历完成，遍历顺序是（<strong>H-&gt;D-&gt;I-&gt;E-&gt;B</strong>），然后遍历A的右，也就是C，把C当作一个根，再遍历C的左，也就是F，把F当作一个根，再遍历他的左也就是J，然后遍历右也就是K，回去遍历根F，然后遍历根C的右，也就是G，然后回去遍历根C，最后回去遍历根A，此时A的右子树遍历完成，所以二叉树遍历完成，遍历顺序是（<strong>H-&gt;D-&gt;I-&gt;E-&gt;B-&gt;J-&gt;K-&gt;F-&gt;G-&gt;C-&gt;A</strong>）</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>通过二叉树的中序和另一种序列，可以得到一颗唯一的二叉树，并推出另一序列。</p>
<h5 id="1-前序中序画树并推出后序序列"><a href="#1-前序中序画树并推出后序序列" class="headerlink" title="1.前序中序画树并推出后序序列"></a>1.前序中序画树并推出后序序列</h5><p> <img src="https://img-blog.csdnimg.cn/2019050314171360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VlYmFpY2Fp,size_16,color_FFFFFF,t_70" alt="å¨è¿éæå
¥å¾çæè¿°"> </p>
<p>解析：由前序序列可以得知，A是二叉树的根，所以再看中序序列，就可以知道，HBDF是二叉树的左子树，EKCG是二叉树的右子树，然后由前序序列还可以得知B是左子树的根结点，然后由中序序列还可以得知H是B的左子树结点，DF是右子树结点，D是F的左子树结点，此时A的左子树就推断完了，然后推右子树，由前序序列得知E是A的右子树根节点，由中序序列得知，E没有左子树，否则遍历完左子树不能立刻遍历E，然后由中序/前序序列可知C是E的右子树结点，K是C的左子树，G是C的右子树，然后画出整个二叉树即可。</p>
<p><img src="https://img-blog.csdnimg.cn/20210209180216664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NkElEOMN-1612864710800)(15.png)]"></p>
<p>再根据二叉树可推知后序序列是 HDFBKGCEA ，因此选择B。</p>
<h5 id="2-中序后序画树并推出前序序列"><a href="#2-中序后序画树并推出前序序列" class="headerlink" title="2.中序后序画树并推出前序序列"></a>2.中序后序画树并推出前序序列</h5><p>中序遍历:    ADEFGHMZ</p>
<p>后序遍历:    AEFDHZMG</p>
<p>解析：由后序序列可知G是二叉树的根节点，由中序序列可知ADEF是左子树，HMZ是右子树，由后序序列可知D是左子树根节点,M是右子树根节点,由后序/中序序列可知,A是D的左子树结点,EF是D的右子树结点,E是F的左子树结点,由中序/后序序列可知H是M的左子树结点,Z是M的右子树结点,然后画出二叉树.</p>
<p><img src="https://img-blog.csdnimg.cn/20210209180245259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-h3cMB5Fg-1612864710801)(16.png)]"></p>
<p>所以前序序列为  GDAFEMHZ </p>
<h3 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//前序创建</span><br><span class="line">void CreatrBiTree(Bitreenode* t)</span><br><span class="line">&#123;</span><br><span class="line">	int data;</span><br><span class="line">	cin &gt;&gt; data;</span><br><span class="line">	if (data == 0)</span><br><span class="line">		*t = NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		*t = new BiTree;</span><br><span class="line">		if (!(*t))</span><br><span class="line">			return;</span><br><span class="line">		(*t)-&gt;data = data;</span><br><span class="line">		CreatrBiTree(&amp;(*t)-&gt;lchild);</span><br><span class="line">		CreatrBiTree(&amp;(*t)-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的遍历-代码实现"><a href="#二叉树的遍历-代码实现" class="headerlink" title="二叉树的遍历(代码实现)"></a>二叉树的遍历(代码实现)</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//前序遍历 根 左 右</span><br><span class="line">void showBiTree(Bitreenode t,int level)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; t-&gt;data &lt;&lt; &quot;在第&quot; &lt;&lt; level &lt;&lt; &quot;层&quot; &lt;&lt; endl;</span><br><span class="line">		showBiTree(t-&gt;lchild,level+1);</span><br><span class="line">		showBiTree(t-&gt;rchild,level+1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//中序遍历  左 根 右</span><br><span class="line">void SHowBiTree(Bitreenode t,int level)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		SHowBiTree(t-&gt;lchild, level + 1);</span><br><span class="line">		cout &lt;&lt; t-&gt;data &lt;&lt; &quot;在第&quot; &lt;&lt; level &lt;&lt; &quot;层&quot; &lt;&lt; endl;</span><br><span class="line">		SHowBiTree(t-&gt;rchild, level + 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//中序遍历  左 根 右</span><br><span class="line">void SHowBiTree(Bitreenode t,int level)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		SHowBiTree(t-&gt;lchild, level + 1);</span><br><span class="line">		cout &lt;&lt; t-&gt;data &lt;&lt; &quot;在第&quot; &lt;&lt; level &lt;&lt; &quot;层&quot; &lt;&lt; endl;</span><br><span class="line">		SHowBiTree(t-&gt;rchild, level + 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树结点数"><a href="#二叉树结点数" class="headerlink" title="二叉树结点数"></a>二叉树结点数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//结点个数</span><br><span class="line">int jiedianmember(Bitreenode t)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return 0;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return jiedianmember(t-&gt;lchild) + jiedianmember(t-&gt;rchild) + 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树子结点数"><a href="#二叉树子结点数" class="headerlink" title="二叉树子结点数"></a>二叉树子结点数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//子结点个数</span><br><span class="line">int zijiedianmember(Bitreenode t)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return 0;</span><br><span class="line">	if (t-&gt;lchild == NULL &amp;&amp; t-&gt;rchild == NULL)</span><br><span class="line">		return 1;</span><br><span class="line">	return zijiedianmember(t-&gt;lchild) + zijiedianmember(t-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="某一层结点数"><a href="#某一层结点数" class="headerlink" title="某一层结点数"></a>某一层结点数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//第k层结点个数   就是求上一层子结点个数 方便写递归</span><br><span class="line">int dikzijiemember(Bitreenode t,int k)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return 0;</span><br><span class="line">	if (k == 0)</span><br><span class="line">		return 1;</span><br><span class="line">	return dikzijiemember(t-&gt;lchild,k-1) + dikzijiemember(t-&gt;rchild,k-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出某一层"><a href="#输出某一层" class="headerlink" title="输出某一层"></a>输出某一层</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//输出第i层</span><br><span class="line">void showiceng(Bitreenode t,int i)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return;</span><br><span class="line">	if (i == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; t-&gt;data&lt;&lt;endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	showiceng(t-&gt;lchild, i-1);</span><br><span class="line">	showiceng(t-&gt;rchild, i-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//层序遍历</span><br><span class="line">void cengshowBiTree(Bitreenode t)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i = 0; i &lt;= 3; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			showiceng(t,i);//输出每层的函数</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找某个数"><a href="#查找某个数" class="headerlink" title="查找某个数"></a>查找某个数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//查找某个数</span><br><span class="line">Bitreenode searchx(Bitreenode t,int x)</span><br><span class="line">&#123;</span><br><span class="line">	Bitreenode boot;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return NULL;</span><br><span class="line">	if (t-&gt;data == x)</span><br><span class="line">		return t;</span><br><span class="line">	boot = searchx(t-&gt;lchild, x);</span><br><span class="line">	if (boot)</span><br><span class="line">		return boot;</span><br><span class="line">	return searchx(t-&gt;rchild, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="销毁二叉树"><a href="#销毁二叉树" class="headerlink" title="销毁二叉树"></a>销毁二叉树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//销毁二叉树</span><br><span class="line">void DestroyBiTree(Bitreenode* t)</span><br><span class="line">&#123;</span><br><span class="line">	if (*t)</span><br><span class="line">	&#123;</span><br><span class="line">		DestroyBiTree(&amp;(*t)-&gt;lchild);</span><br><span class="line">		DestroyBiTree(&amp;(*t)-&gt;rchild);</span><br><span class="line">		delete (*t);</span><br><span class="line">		*t = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct BiTree</span><br><span class="line">&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct BiTree* lchild,*rchild;</span><br><span class="line">&#125;BiTree,*Bitreenode;</span><br><span class="line"></span><br><span class="line">//前序创建</span><br><span class="line">void CreatrBiTree(Bitreenode* t)</span><br><span class="line">&#123;</span><br><span class="line">	int data;</span><br><span class="line">	cin &gt;&gt; data;</span><br><span class="line">	if (data == 0)</span><br><span class="line">		*t = NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		*t = new BiTree;</span><br><span class="line">		if (!(*t))</span><br><span class="line">			return;</span><br><span class="line">		(*t)-&gt;data = data;</span><br><span class="line">		CreatrBiTree(&amp;(*t)-&gt;lchild);</span><br><span class="line">		CreatrBiTree(&amp;(*t)-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//前序遍历 根 左 右</span><br><span class="line">void showBiTree(Bitreenode t,int level)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; t-&gt;data &lt;&lt; &quot;在第&quot; &lt;&lt; level &lt;&lt; &quot;层&quot; &lt;&lt; endl;</span><br><span class="line">		showBiTree(t-&gt;lchild,level+1);</span><br><span class="line">		showBiTree(t-&gt;rchild,level+1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//中序遍历  左 根 右</span><br><span class="line">void SHowBiTree(Bitreenode t,int level)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		SHowBiTree(t-&gt;lchild, level + 1);</span><br><span class="line">		cout &lt;&lt; t-&gt;data &lt;&lt; &quot;在第&quot; &lt;&lt; level &lt;&lt; &quot;层&quot; &lt;&lt; endl;</span><br><span class="line">		SHowBiTree(t-&gt;rchild, level + 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后序遍历 左 右 根</span><br><span class="line">void SHOWBiTree(Bitreenode t, int level)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		SHOWBiTree(t-&gt;lchild,level+1);</span><br><span class="line">		SHOWBiTree(t-&gt;rchild,level+1);</span><br><span class="line">		cout &lt;&lt; t-&gt;data &lt;&lt; &quot;在第&quot; &lt;&lt; level &lt;&lt; &quot;层&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//销毁二叉树</span><br><span class="line">void DestroyBiTree(Bitreenode* t)</span><br><span class="line">&#123;</span><br><span class="line">	if (*t)</span><br><span class="line">	&#123;</span><br><span class="line">		DestroyBiTree(&amp;(*t)-&gt;lchild);</span><br><span class="line">		DestroyBiTree(&amp;(*t)-&gt;rchild);</span><br><span class="line">		delete (*t);</span><br><span class="line">		*t = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//结点个数</span><br><span class="line">int jiedianmember(Bitreenode t)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return 0;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return jiedianmember(t-&gt;lchild) + jiedianmember(t-&gt;rchild) + 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子结点个数</span><br><span class="line">int zijiedianmember(Bitreenode t)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return 0;</span><br><span class="line">	if (t-&gt;lchild == NULL &amp;&amp; t-&gt;rchild == NULL)</span><br><span class="line">		return 1;</span><br><span class="line">	return zijiedianmember(t-&gt;lchild) + zijiedianmember(t-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第k层结点个数   就是求上一层子结点个数 方便写递归</span><br><span class="line">int dikzijiemember(Bitreenode t,int k)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return 0;</span><br><span class="line">	if (k == 0)</span><br><span class="line">		return 1;</span><br><span class="line">	return dikzijiemember(t-&gt;lchild,k-1) + dikzijiemember(t-&gt;rchild,k-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出第i层</span><br><span class="line">void showiceng(Bitreenode t,int i)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return;</span><br><span class="line">	if (i == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; t-&gt;data&lt;&lt;endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	showiceng(t-&gt;lchild, i-1);</span><br><span class="line">	showiceng(t-&gt;rchild, i-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//层序遍历</span><br><span class="line">void cengshowBiTree(Bitreenode t)</span><br><span class="line">&#123;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i = 0; i &lt;= 3; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			showiceng(t,i);//输出每层的函数</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找某个数</span><br><span class="line">Bitreenode searchx(Bitreenode t,int x)</span><br><span class="line">&#123;</span><br><span class="line">	Bitreenode boot;</span><br><span class="line">	if (t == NULL)</span><br><span class="line">		return NULL;</span><br><span class="line">	if (t-&gt;data == x)</span><br><span class="line">		return t;</span><br><span class="line">	boot = searchx(t-&gt;lchild, x);</span><br><span class="line">	if (boot)</span><br><span class="line">		return boot;</span><br><span class="line">	return searchx(t-&gt;rchild, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Bitreenode tree;</span><br><span class="line">	CreatrBiTree(&amp;tree);</span><br><span class="line">	showBiTree(tree, 0);</span><br><span class="line">	SHowBiTree(tree, 0);</span><br><span class="line">	SHOWBiTree(tree, 0);</span><br><span class="line">	int ret=jiedianmember(tree);</span><br><span class="line">	cout &lt;&lt;&quot;结点个数为：&quot;&lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">	int Ret = zijiedianmember(tree);</span><br><span class="line">	cout&lt;&lt;&quot;子结点个数为:&quot;&lt;&lt;Ret&lt;&lt;endl;</span><br><span class="line">	int REt = dikzijiemember(tree, 1);</span><br><span class="line">	cout &lt;&lt; &quot;第一层结点个数为:&quot; &lt;&lt; REt &lt;&lt; endl;</span><br><span class="line">	showiceng(tree, 2);</span><br><span class="line">	cengshowBiTree(tree);</span><br><span class="line">	tree=searchx(tree, 5);</span><br><span class="line">	cout &lt;&lt; tree;</span><br><span class="line">	DestroyBiTree(&amp;tree);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树和二叉树的转换"><a href="#树和二叉树的转换" class="headerlink" title="树和二叉树的转换"></a>树和二叉树的转换</h2><h3 id="树转二叉树"><a href="#树转二叉树" class="headerlink" title="树转二叉树"></a>树转二叉树</h3><p>1.加线:在兄弟之间加一连线</p>
<p>2.抹线:对每个结点,除了左孩子外,去除与其余孩子之间的关系</p>
<p>3.旋转:一树的根结点为轴心,将整数顺时针旋转45°</p>
<p>例子:</p>
<p><img src="https://img-blog.csdnimg.cn/2021020918030618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Y6Kepqv1-1612864710802)(../AppData/Roaming/Typora/typora-user-images/1612518201847.png)]"></p>
<h3 id="二叉树转树"><a href="#二叉树转树" class="headerlink" title="二叉树转树"></a>二叉树转树</h3><p>1.加线:若某一结点是双亲结点的左孩子,则将该结点的右孩子,右孩子的右孩子…沿分支找到的所有右孩子,都与该结点的双亲用线连起来.</p>
<p>2.抹线:抹掉原二叉树中双亲与右孩子之间的连线</p>
<p>3.调整:将结点按层次排列,形成树结构</p>
<p>例子:</p>
<p><img src="https://img-blog.csdnimg.cn/20210209180321138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-s7jBhcYq-1612864710802)(../AppData/Roaming/Typora/typora-user-images/1612518533827.png)]"></p>
<h2 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>多颗互不相交的树的集合；</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质:"></a>性质:</h3><p>树中的结点数等于所有结点的度数加1（含有n个结点的树边数为n-1）</p>
<p>树中有n-1条边，所有结点的度数为n-1  -&gt;此树中含有n个结点</p>
<p>m叉树中中第i层最多有m^(i-1)个结点；</p>
<p>第一层1个，第二程m个，第三层m^2个，数学归纳法得出第i层最多有m^(i-1)个</p>
<p>树高为h的m叉树最多有(m^h-1)/(m-1)个结点；</p>
<p>1+m+m^2+…..+m^(h-1) 等比数列求和</p>
<p>含有n个结点的m叉树的最小高度为  logm[n(m-1)+1]上取整；</p>
<p>让每一层都达到最大结点数，所形成的树高度最小；</p>
<p>(m^h-1)/(m-1)&gt;=n且(m^(h-1)-1)/(m-1)&lt;n；</p>
<p>求解两方程得出</p>
<p>logm[n(m-1)+1]&lt;=h&lt;logm[n(m-1)+1]+1</p>
<h2 id="森林和二叉树的转换"><a href="#森林和二叉树的转换" class="headerlink" title="森林和二叉树的转换"></a>森林和二叉树的转换</h2><h3 id="森林转二叉树"><a href="#森林转二叉树" class="headerlink" title="森林转二叉树"></a>森林转二叉树</h3><p>1.转换:将各棵树分别转换成二叉树</p>
<p>2.连线:将每棵树的根节点用线相连</p>
<p>3.旋转:以第一棵树根节点为二叉树的根,再以根节点为轴心,顺时针旋转,构成二叉树型结构</p>
<p>例子:</p>
<p><img src="https://img-blog.csdnimg.cn/20210209180335482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vsSInuOJ-1612864710802)(../AppData/Roaming/Typora/typora-user-images/1612519002510.png)]"></p>
<h3 id="二叉树转森林"><a href="#二叉树转森林" class="headerlink" title="二叉树转森林"></a>二叉树转森林</h3><p>1.抹线:将二叉树根节点与其右孩子连线,及沿右分支搜索到的所有右孩子间连线全部抹掉,使之变成孤立的二叉树</p>
<p>2.还原:将孤立的二叉树还原成树</p>
<p><img src="https://img-blog.csdnimg.cn/2021020918034986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-s9wUymIc-1612864710803)(../AppData/Roaming/Typora/typora-user-images/1612519637125.png)]"></p>
<h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p><img src="https://img-blog.csdnimg.cn/20210209180359163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LEwRvuGM-1612864710803)(../AppData/Roaming/Typora/typora-user-images/1612519932724.png)]"></p>
<h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><p><img src="https://img-blog.csdnimg.cn/20210209180407103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-c4TvRym1-1612864710804)(../AppData/Roaming/Typora/typora-user-images/1612521281836.png)]"></p>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p><img src="https://img-blog.csdnimg.cn/20210209180417690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5PakhkqP-1612864710804)(../AppData/Roaming/Typora/typora-user-images/1612521406607.png)]"></p>
<h4 id="中序遍历-2"><a href="#中序遍历-2" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><img src="https://img-blog.csdnimg.cn/20210209180426174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tyecMBBA-1612864710804)(../AppData/Roaming/Typora/typora-user-images/1612521482742.png)]"></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h4><p><img src="https://img-blog.csdnimg.cn/20210209180436678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-T1DpNmqD-1612864710805)(../AppData/Roaming/Typora/typora-user-images/1612521538713.png)]"></p>
<h2 id="哈夫曼树-最优二叉树"><a href="#哈夫曼树-最优二叉树" class="headerlink" title="哈夫曼树(最优二叉树)"></a>哈夫曼树(最优二叉树)</h2><h3 id="哈夫曼树的基本概念"><a href="#哈夫曼树的基本概念" class="headerlink" title="哈夫曼树的基本概念"></a>哈夫曼树的基本概念</h3><p><img src="https://img-blog.csdnimg.cn/20210209180446155.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oebjRdp7-1612864710805)(../AppData/Roaming/Typora/typora-user-images/1612533040621.png)]"></p>
<p><img src="https://img-blog.csdnimg.cn/20210209180454181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IhCHDKfC-1612864710805)(../AppData/Roaming/Typora/typora-user-images/1612533729985.png)]"></p>
<p><img src="https://img-blog.csdnimg.cn/20210209180501627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bSsZlZWA-1612864710806)(../AppData/Roaming/Typora/typora-user-images/1612533641837.png)]"></p>
<p><img src="https://img-blog.csdnimg.cn/20210209180510647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-KPTesH2i-1612864710806)(../AppData/Roaming/Typora/typora-user-images/1612534122094.png)]"></p>
<p><img src="https://img-blog.csdnimg.cn/20210209180519280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1xMKCZZ7-1612864710807)(../AppData/Roaming/Typora/typora-user-images/1612534591766.png)]"></p>
<h3 id="哈夫曼树的构建"><a href="#哈夫曼树的构建" class="headerlink" title="哈夫曼树的构建"></a>哈夫曼树的构建</h3><p><img src="https://img-blog.csdnimg.cn/2021020918052847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mySJyTna-1612864710807)(../AppData/Roaming/Typora/typora-user-images/1612535893678.png)]"></p>
<h3 id="构建代码实现"><a href="#构建代码实现" class="headerlink" title="构建代码实现"></a>构建代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct huff</span><br><span class="line">&#123;</span><br><span class="line">	int weight;</span><br><span class="line">	int parent, lchild, rchild;</span><br><span class="line">&#125;huff,*hufftree;</span><br></pre></td></tr></table></figure>

<p>首先初始化令 parent=0, lchild=0, rchild=0，然后初始化n个叶子节点，输入0-n结点的权值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void createbufftree(hufftree hf)</span><br><span class="line">&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	if (n &lt;= 1)</span><br><span class="line">		return;</span><br><span class="line">	m = 2 * n - 1;//数组有2n-1个元素</span><br><span class="line">	hf = new huff[m];//申请n个也就是2n-1个空间，0-n</span><br><span class="line">	for (int i = 0; i &lt; m; i++)//将 2n-1个结点都初始化</span><br><span class="line">	&#123;</span><br><span class="line">		hf-&gt;lchild = 0;</span><br><span class="line">		hf-&gt;rchild = 0;</span><br><span class="line">		hf-&gt;parent = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)//输入前n个结点的权值</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; hf[i].weight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成后，进行下面n-1次合并，依次产生n-1个结点hf[i]，i=n-2n，在[0…i]中选两个未被选过的，且parent==0的结点中选权值最小的两个结点：hf[s1],hf[s2]</p>
<p>然后修改这两个结点的parent值，hf[s1].parent=i,hf[s2].parent=i</p>
<p>然后修改新产生的hf[i]，hf[i].weifht=hf[s1].weight+hf[s2].weight，hf[i].lchild=s1，hf[i].rchild=s2.</p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p><img src="https://img-blog.csdnimg.cn/20210209180539472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wBU8URvc-1612864710807)(../AppData/Roaming/Typora/typora-user-images/1612621588678.png)]"></p>
<p><img src="https://img-blog.csdnimg.cn/20210209180601855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-D6oREIH9-1612864710808)(../AppData/Roaming/Typora/typora-user-images/1612621694893.png)]"></p>
<p><img src="https://img-blog.csdnimg.cn/20210209180646435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-W0LtV5k3-1612864710808)(../AppData/Roaming/Typora/typora-user-images/1612621738965.png)]"></p>
<p><img src="https://img-blog.csdnimg.cn/20210209180704767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OrOm4RRQ-1612864710809)(../AppData/Roaming/Typora/typora-user-images/1612621802126.png)]"></p>
<p><img src="https://img-blog.csdnimg.cn/20210209180712527.png#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-88HjOHkL-1612864710809)(../AppData/Roaming/Typora/typora-user-images/1612621835151.png)]"></p>
<p><img src="https://img-blog.csdnimg.cn/20210209180720602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cnKXYfnt-1612864710810)(../AppData/Roaming/Typora/typora-user-images/1612621863937.png)]"></p>
<p><img src="https://img-blog.csdnimg.cn/20210209180729608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gxJiBSK2-1612864710810)(../AppData/Roaming/Typora/typora-user-images/1612624303720.png)]"></p>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#pragma warning (disable:4996)</span><br><span class="line">#define maxSize 100</span><br><span class="line">/*</span><br><span class="line">赫夫曼树的存储结构，它也是一种二叉树结构，</span><br><span class="line">这种存储结构既适合表示树，也适合表示森林。</span><br><span class="line">*/</span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">	int weight;                //权值  </span><br><span class="line">	int parent;                //父节点的序号，为-1的是根节点  </span><br><span class="line">	int lchild, rchild;         //左右孩子节点的序号，为-1的是叶子节点  </span><br><span class="line">&#125;HTNode, *HuffmanTree;          //用来存储赫夫曼树中的所有节点  </span><br><span class="line">typedef char **HuffmanCode;    //用来存储每个叶子节点的赫夫曼编码  </span><br><span class="line"></span><br><span class="line">HuffmanTree create_HuffmanTree(int *wet, int n);</span><br><span class="line">void select_minium(HuffmanTree HT, int k, int &amp;min1, int &amp;min2);</span><br><span class="line">int min(HuffmanTree HT, int k);</span><br><span class="line">void HuffmanCoding1(HuffmanTree HT, HuffmanCode &amp;HC, int n);</span><br><span class="line">void HuffmanCoding2(HuffmanTree HT, HuffmanCode &amp;HC, int n);</span><br><span class="line">int countWPL1(HuffmanTree HT, int n);</span><br><span class="line">int countWPL2(HuffmanTree HT, int n);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int  w[] = &#123; 5,4,3,2,1 &#125;;//用数组w存储各个权值</span><br><span class="line">	int n=5;//表示数组w中的个数</span><br><span class="line"></span><br><span class="line">	HuffmanCode HC = NULL;</span><br><span class="line">	HuffmanTree hTree = create_HuffmanTree(w, n);</span><br><span class="line">	int wpl1 = countWPL1(hTree, n);</span><br><span class="line">	printf(&quot;从叶子结点开始遍历二叉树求最小带权路径长度WPL=%d\n&quot;, wpl1);</span><br><span class="line"></span><br><span class="line">	int wpl2 = countWPL2(hTree, n);</span><br><span class="line">	printf(&quot;从根结点开始遍历二叉树求最小带权路径长度WPL=%d\n&quot;, wpl2);</span><br><span class="line"></span><br><span class="line">	printf(&quot;\n从叶子到根结点编码结果为：\n&quot;);</span><br><span class="line">	HuffmanCoding1(hTree, HC, n);</span><br><span class="line"></span><br><span class="line">	printf(&quot;\n从根结点到叶子结点编码结果为：\n&quot;);</span><br><span class="line">	HuffmanCoding2(hTree, HC, n);</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*根据给定的n个权值构造一棵赫夫曼树,wet中存放n个权值*/</span><br><span class="line">HuffmanTree create_HuffmanTree(int *wet, int n)</span><br><span class="line">&#123;</span><br><span class="line">	//一棵有n个叶子节点的赫夫曼树共有2n-1个节点  </span><br><span class="line">	int total = 2 * n - 1;</span><br><span class="line">	HuffmanTree HT = (HuffmanTree)malloc(total * sizeof(HTNode));</span><br><span class="line">	if (!HT)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;HuffmanTree malloc faild!&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	//以下初始化序号全部用-1表示，  </span><br><span class="line">	//这样在编码函数中进行循环判断parent或lchild或rchild的序号时，  </span><br><span class="line">	//不会与HT数组中的任何一个下标混淆  </span><br><span class="line"></span><br><span class="line">	//HT[0],HT[1]...HT[n-1]中存放需要编码的n个叶子节点  </span><br><span class="line">	for (i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		HT[i].parent = -1;</span><br><span class="line">		HT[i].lchild = -1;</span><br><span class="line">		HT[i].rchild = -1;</span><br><span class="line">		HT[i].weight = *wet;</span><br><span class="line">		wet++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//HT[n],HT[n+1]...HT[2n-2]中存放的是中间构造出的每棵二叉树的根节点  </span><br><span class="line">	for (; i &lt; total; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		HT[i].parent = -1;</span><br><span class="line">		HT[i].lchild = -1;</span><br><span class="line">		HT[i].rchild = -1;</span><br><span class="line">		HT[i].weight = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int min1, min2; //用来保存每一轮选出的两个weight最小且parent为0的节点  </span><br><span class="line">//每一轮比较后选择出min1和min2构成一课二叉树,最后构成一棵赫夫曼树  </span><br><span class="line">	for (i = n; i &lt; total; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		select_minium(HT, i, min1, min2);</span><br><span class="line">		HT[min1].parent = i;</span><br><span class="line">		HT[min2].parent = i;</span><br><span class="line">		//这里左孩子和右孩子可以反过来，构成的也是一棵赫夫曼树，只是所得的编码不同  </span><br><span class="line">		HT[i].lchild = min1;</span><br><span class="line">		HT[i].rchild = min2;</span><br><span class="line">		HT[i].weight = HT[min1].weight + HT[min2].weight;</span><br><span class="line">	&#125;</span><br><span class="line">	return HT;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">从HT数组的前k个元素中选出weight最小且parent为-1的两个，分别将其序号保存在min1和min2中</span><br><span class="line">*/</span><br><span class="line">void select_minium(HuffmanTree HT, int k, int &amp;min1, int &amp;min2)</span><br><span class="line">&#123;</span><br><span class="line">	min1 = min(HT, k);</span><br><span class="line">	min2 = min(HT, k);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">从HT数组的前k个元素中选出weight最小且parent为-1的元素，并将该元素的序号返回</span><br><span class="line">*/</span><br><span class="line">int min(HuffmanTree HT, int k)</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	int min;        //用来存放weight最小且parent为-1的元素的序号  </span><br><span class="line">	int min_weight; //用来存放weight最小且parent为-1的元素的weight值  </span><br><span class="line"></span><br><span class="line">//先将第一个parent为-1的元素的weight值赋给min_weight,留作以后比较用。  </span><br><span class="line">//注意，这里不能按照一般的做法，先直接将HT[0].weight赋给min_weight，  </span><br><span class="line">//因为如果HT[0].weight的值比较小，那么在第一次构造二叉树时就会被选走，  </span><br><span class="line">//而后续的每一轮选择最小权值构造二叉树的比较还是先用HT[0].weight的值来进行判断，  </span><br><span class="line">//这样又会再次将其选走，从而产生逻辑上的错误。  </span><br><span class="line">	while (HT[i].parent != -1)</span><br><span class="line">		i++;</span><br><span class="line">	min_weight = HT[i].weight;</span><br><span class="line">	min = i;</span><br><span class="line"></span><br><span class="line">	//选出weight最小且parent为-1的元素，并将其序号赋给min  </span><br><span class="line">	for (; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (HT[i].weight &lt; min_weight &amp;&amp; HT[i].parent == -1)</span><br><span class="line">		&#123;</span><br><span class="line">			min_weight = HT[i].weight;</span><br><span class="line">			min = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//选出weight最小的元素后，将其parent置1，使得下一次比较时将其排除在外。  </span><br><span class="line">	HT[min].parent = 1;</span><br><span class="line"></span><br><span class="line">	return min;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">从叶子节点到根节点逆向求赫夫曼树HT中n个叶子节点的赫夫曼编码，并保存在HC中</span><br><span class="line">*/</span><br><span class="line">void HuffmanCoding1(HuffmanTree HT, HuffmanCode &amp;HC, int n)</span><br><span class="line">&#123;</span><br><span class="line">	//用来保存指向每个赫夫曼编码串的指针</span><br><span class="line">	HC = (HuffmanCode)malloc(n * sizeof(char *));</span><br><span class="line">	if (!HC)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;HuffmanCode malloc faild!&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//临时空间，用来保存每次求得的赫夫曼编码串</span><br><span class="line">	//对于有n个叶子节点的赫夫曼树，各叶子节点的编码长度最长不超过n-1</span><br><span class="line">	//外加一个&#x27;\0&#x27;结束符，因此分配的数组长度最长为n即可</span><br><span class="line">	char *code = (char *)malloc(n * sizeof(char));</span><br><span class="line">	if (!code)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;code malloc faild!&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	code[n - 1] = &#x27;\0&#x27;;  //编码结束符，亦是字符数组的结束标志</span><br><span class="line">						 //求每个字符的赫夫曼编码</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int current = i;           //定义当前访问的节点</span><br><span class="line">		int father = HT[i].parent; //当前节点的父节点</span><br><span class="line">		int start = n - 1;           //每次编码的位置，初始为编码结束符的位置</span><br><span class="line">									 //从叶子节点遍历赫夫曼树直到根节点</span><br><span class="line">		while (father != -1)</span><br><span class="line">		&#123;</span><br><span class="line">			if (HT[father].lchild == current)   //如果是左孩子，则编码为0</span><br><span class="line">				code[--start] = &#x27;0&#x27;;</span><br><span class="line">			else                              //如果是右孩子，则编码为1       </span><br><span class="line">				code[--start] = &#x27;1&#x27;;</span><br><span class="line">			current = father;</span><br><span class="line">			father = HT[father].parent;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//为第i个字符的编码串分配存储空间</span><br><span class="line">		HC[i] = (char *)malloc((n - start) * sizeof(char));</span><br><span class="line">		if (!HC[i])</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;HC[i] malloc faild!&quot;);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line">		//将编码串从code复制到HC</span><br><span class="line">		strcpy(HC[i], code + start);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">		printf(&quot;%s\n&quot;, HC[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	free(code); //释放保存编码串的临时空间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">从根节点到叶子节点无栈非递归遍历赫夫曼树HT，求其中n个叶子节点的赫夫曼编码，并保存在HC中</span><br><span class="line">*/</span><br><span class="line">void HuffmanCoding2(HuffmanTree HT, HuffmanCode &amp;HC, int n)</span><br><span class="line">&#123;</span><br><span class="line">	//用来保存指向每个赫夫曼编码串的指针  </span><br><span class="line">	HC = (HuffmanCode)malloc(n * sizeof(char *));</span><br><span class="line">	if (!HC)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;HuffmanCode malloc faild!&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//临时空间，用来保存每次求得的赫夫曼编码串  </span><br><span class="line">	//对于有n个叶子节点的赫夫曼树，各叶子节点的编码长度最长不超过n-1  </span><br><span class="line">	//外加一个&#x27;\0&#x27;结束符，因此分配的数组长度最长为n即可  </span><br><span class="line">	char *code = (char *)malloc(n * sizeof(char));</span><br><span class="line">	if (!code)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;code malloc faild!&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int cur = 2 * n - 2;    //当前遍历到的节点的序号，初始时为根节点序号  </span><br><span class="line">	int code_len = 0;   //定义编码的长度  </span><br><span class="line"></span><br><span class="line">//构建好赫夫曼树后，把weight用来当做遍历树时每个节点的状态标志  </span><br><span class="line">//weight=0表明当前节点的左右孩子都还没有被遍历  </span><br><span class="line">//weight=1表示当前节点的左孩子已经被遍历过，右孩子尚未被遍历  </span><br><span class="line">//weight=2表示当前节点的左右孩子均被遍历过  </span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; cur + 1; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		HT[i].weight = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//从根节点开始遍历，最后回到根节点结束  </span><br><span class="line">	//当cur为根节点的parent时，退出循环  </span><br><span class="line">	while (cur != -1)</span><br><span class="line">	&#123;</span><br><span class="line">		//左右孩子均未被遍历，先向左遍历  </span><br><span class="line">		if (HT[cur].weight == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			HT[cur].weight = 1;    //表明其左孩子已经被遍历过了  </span><br><span class="line">			if (HT[cur].lchild != -1)</span><br><span class="line">			&#123;   //如果当前节点不是叶子节点，则记下编码，并继续向左遍历  </span><br><span class="line">				code[code_len++] = &#x27;0&#x27;;</span><br><span class="line">				cur = HT[cur].lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;   //如果当前节点是叶子节点，则终止编码，并将其保存起来  </span><br><span class="line">				code[code_len] = &#x27;\0&#x27;;</span><br><span class="line">				HC[cur] = (char *)malloc((code_len + 1) * sizeof(char));</span><br><span class="line">				if (!HC[cur])</span><br><span class="line">				&#123;</span><br><span class="line">					printf(&quot;HC[cur] malloc faild!&quot;);</span><br><span class="line">					exit(-1);</span><br><span class="line">				&#125;</span><br><span class="line">				strcpy(HC[cur], code);  //复制编码串  </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//左孩子已被遍历，开始向右遍历右孩子  </span><br><span class="line">		else if (HT[cur].weight == 1)</span><br><span class="line">		&#123;</span><br><span class="line">			HT[cur].weight = 2;   //表明其左右孩子均被遍历过了  </span><br><span class="line">			if (HT[cur].rchild != -1)</span><br><span class="line">			&#123;   //如果当前节点不是叶子节点，则记下编码，并继续向右遍历  </span><br><span class="line">				code[code_len++] = &#x27;1&#x27;;</span><br><span class="line">				cur = HT[cur].rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//左右孩子均已被遍历，退回到父节点，同时编码长度减1  </span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			HT[cur].weight = 0;</span><br><span class="line">			cur = HT[cur].parent;</span><br><span class="line">			--code_len;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">		printf(&quot;%s\n&quot;, HC[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	free(code);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">从叶子结点开始遍历二叉树直到根结点，根结点为HT[2n-1],且HT[2n-1].parent=-1;</span><br><span class="line">各叶子结点为HT[0]、HT[1]...HT[n-1]。</span><br><span class="line">关键步骤是求出各个叶子结点的路径长度，用此路径长度*此结点的权值就是</span><br><span class="line">此结点带权路径长度，最后将各个叶子结点的带权路径长度加起来即可。</span><br><span class="line">*/</span><br><span class="line">int countWPL1(HuffmanTree HT, int n)</span><br><span class="line">&#123;</span><br><span class="line">	int i,countRoads,WPL=0;</span><br><span class="line">	/*</span><br><span class="line">	由creat_huffmanTree（）函数可知，HT[0]、HT[1]...HT[n-1]存放的就是各个叶子结点，</span><br><span class="line">	所以挨个求叶子结点的带权路径长度即可</span><br><span class="line">	*/</span><br><span class="line">	for (i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int father = HT[i].parent; //当前节点的父节点</span><br><span class="line">		countRoads = 0;//置当前路径长度为0</span><br><span class="line">		//从叶子节点遍历赫夫曼树直到根节点</span><br><span class="line">		while (father != -1)</span><br><span class="line">		&#123;</span><br><span class="line">			countRoads++;</span><br><span class="line">			father = HT[father].parent;</span><br><span class="line">		&#125;</span><br><span class="line">		WPL += countRoads * HT[i].weight;</span><br><span class="line">	&#125;</span><br><span class="line">	return WPL;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">以下是从根结点开始遍历二叉树，求最小带权路径长度。关键步骤是求出各个叶子</span><br><span class="line">结点的路径长度，用此路径长度*此结点的权值就是此结点带权路径长度，最后将</span><br><span class="line">各个叶子结点的带权路径长度加起来即可。</span><br><span class="line">*/</span><br><span class="line">int countWPL2(HuffmanTree HT, int n)</span><br><span class="line">&#123;</span><br><span class="line">	int cur = 2 * n - 2;    //当前遍历到的节点的序号，初始时为根节点序号  </span><br><span class="line">	int countRoads=0, WPL=0;//countRoads保存叶子结点的路径长度</span><br><span class="line"></span><br><span class="line">//构建好赫夫曼树后，把visit[]用来当做遍历树时每个节点的状态标志  </span><br><span class="line">//visit[cur]=0表明当前节点的左右孩子都还没有被遍历  </span><br><span class="line">//visit[cur]=1表示当前节点的左孩子已经被遍历过，右孩子尚未被遍历  </span><br><span class="line">//visit[cur]=2表示当前节点的左右孩子均被遍历过  </span><br><span class="line">	int visit[maxSize] = &#123; 0 &#125;;//visit[]是标注数组,初始化为0</span><br><span class="line"></span><br><span class="line">	//从根节点开始遍历，最后回到根节点结束  </span><br><span class="line">	//当cur为根节点的parent时，退出循环  </span><br><span class="line">	while (cur != -1)</span><br><span class="line">	&#123;</span><br><span class="line">		//左右孩子均未被遍历，先向左遍历  </span><br><span class="line">		if (visit[cur]==0)</span><br><span class="line">		&#123;</span><br><span class="line">			visit[cur] = 1;    //表明其左孩子已经被遍历过了  </span><br><span class="line">			if (HT[cur].lchild != -1)</span><br><span class="line">			&#123;   //如果当前节点不是叶子节点，则路径长度+1，并继续向左遍历  </span><br><span class="line">				countRoads++;</span><br><span class="line">				cur = HT[cur].lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;   //如果当前节点是叶子节点，则计算此结点的带权路径长度，并将其保存起来  </span><br><span class="line">				WPL += countRoads * HT[cur].weight;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//左孩子已被遍历，开始向右遍历右孩子  </span><br><span class="line">		else if (visit[cur]==1)</span><br><span class="line">		&#123;</span><br><span class="line">			visit[cur] = 2;</span><br><span class="line">			if (HT[cur].rchild != -1)</span><br><span class="line">			&#123;   //如果当前节点不是叶子节点，则记下编码，并继续向右遍历  </span><br><span class="line">				countRoads++;</span><br><span class="line">				cur = HT[cur].rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//左右孩子均已被遍历，退回到父节点，同时路径长度-1 </span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			visit[cur] = 0;</span><br><span class="line">			cur = HT[cur].parent;</span><br><span class="line">			--countRoads;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return WPL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><p>G=(V,E)</p>
<p>V：顶点（数据元素）的有穷非空集合</p>
<p>E：边的有穷集合</p>
<p>图按照边的有无方向分为无向图和有向图。无向图由顶点和边组成，有向图由顶点和弧构成。弧有弧尾和弧头之分，带箭头一端为弧头。 </p>
<h4 id="无向图："><a href="#无向图：" class="headerlink" title="无向图："></a>无向图：</h4><p>每条边都是无方向的</p>
<h4 id="有向图："><a href="#有向图：" class="headerlink" title="有向图："></a>有向图：</h4><p>每条边都是有方向的</p>
<p><img src="https://img-blog.csdnimg.cn/20210209180745584.png#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hqkqF8rl-1612864710811)(../AppData/Roaming/Typora/typora-user-images/1612796780465.png)]"></p>
<h4 id="完全图："><a href="#完全图：" class="headerlink" title="完全图："></a>完全图：</h4><p>任意两个点都有一条边相连</p>
<p><img src="https://img-blog.csdnimg.cn/20210209180754418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-KnHau4R1-1612864710811)(../AppData/Roaming/Typora/typora-user-images/1612796840030.png)]"></p>
<h4 id="稀疏图："><a href="#稀疏图：" class="headerlink" title="稀疏图："></a>稀疏图：</h4><p>有很少边或弧的图（e&lt;nlogn）</p>
<h4 id="稠密图："><a href="#稠密图：" class="headerlink" title="稠密图："></a>稠密图：</h4><p>有很多边或弧的图</p>
<h4 id="网："><a href="#网：" class="headerlink" title="网："></a>网：</h4><p>边/弧带权的图</p>
<h4 id="邻接："><a href="#邻接：" class="headerlink" title="邻接："></a>邻接：</h4><p>​           有边/弧相连的两个顶点之间的关系</p>
<p>​            存在（vi,vj）（无向图，两点直接有线），则称vi,vj互为邻接点</p>
<p>​            存在  &lt;vi,vj&gt;（有向图，从vi到vj有线），则称vi邻接到vj，vj邻接于vi</p>
<h4 id="关联（依附）："><a href="#关联（依附）：" class="headerlink" title="关联（依附）："></a>关联（依附）：</h4><p>​              边/弧与顶点之间的关系</p>
<p>​              存在（vi,vj）/&lt;vi,vj&gt;，则称该边/弧关联与vi和vj</p>
<h4 id="顶点的度："><a href="#顶点的度：" class="headerlink" title="顶点的度："></a>顶点的度：</h4><p>​      与该顶点相关联的边的数目，记为TD（v）</p>
<p>​      在有向图中，顶点的度等于该顶点的入度和出度之和</p>
<p>​      顶点v的入度是以v为终点的有向边的条数，记作ID（v）</p>
<p>​      顶点v的出度是以v为始点的有向边的条数，记作OD（v）</p>
<p><img src="https://img-blog.csdnimg.cn/2021020918080567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-f35vQtbS-1612864710811)(../AppData/Roaming/Typora/typora-user-images/1612797419902.png)]"></p>
<p>当有向图中仅一个顶点的入度为0，其余顶点的入度均为1，此时是有向树</p>
<p><img src="https://img-blog.csdnimg.cn/20210209180813604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8AAH3TQq-1612864710811)(../AppData/Roaming/Typora/typora-user-images/1612797509140.png)]"></p>
<h4 id="路径："><a href="#路径：" class="headerlink" title="路径："></a>路径：</h4><p>接续的边（若干条）构成的顶点序列</p>
<h4 id="路径长度："><a href="#路径长度：" class="headerlink" title="路径长度："></a>路径长度：</h4><p>路径上边或弧的数目/权值之和</p>
<h4 id="回路（环）："><a href="#回路（环）：" class="headerlink" title="回路（环）："></a>回路（环）：</h4><p>第一个顶点和最后一个顶点相同的路径</p>
<h4 id="简单路径："><a href="#简单路径：" class="headerlink" title="简单路径："></a>简单路径：</h4><p>除路径起点和终点相同外，其余顶点均不相同的路径</p>
<p><img src="https://img-blog.csdnimg.cn/20210209180824159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XOUHqCml-1612864710812)(../AppData/Roaming/Typora/typora-user-images/1612798024350.png)]"></p>
<h4 id="连通图（强连通图）："><a href="#连通图（强连通图）：" class="headerlink" title="连通图（强连通图）："></a>连通图（强连通图）：</h4><p><img src="https://img-blog.csdnimg.cn/20210209180833971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1hKveQRs-1612864710813)(../AppData/Roaming/Typora/typora-user-images/1612798147307.png)]"></p>
<h4 id="权与网："><a href="#权与网：" class="headerlink" title="权与网："></a>权与网：</h4><p>图中边或弧所具有的相关数称为权，表明从一个顶点到另一个顶点的距离或损耗。</p>
<p>带权的图称为网</p>
<h4 id="子图："><a href="#子图：" class="headerlink" title="子图："></a>子图：</h4><p><img src="https://img-blog.csdnimg.cn/20210209180842925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ggcnhzDQ-1612864710813)(../AppData/Roaming/Typora/typora-user-images/1612798303851.png)]"></p>
<h4 id="连通分量（强连通分量）："><a href="#连通分量（强连通分量）：" class="headerlink" title="连通分量（强连通分量）："></a>连通分量（强连通分量）：</h4><p><img src="https://img-blog.csdnimg.cn/20210209180852436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ySXZVPAT-1612864710814)(../AppData/Roaming/Typora/typora-user-images/1612798428016.png)]"></p>
<p><img src="https://img-blog.csdnimg.cn/20210209180901648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OVq4dzH3-1612864710814)(../AppData/Roaming/Typora/typora-user-images/1612798573778.png)]"></p>
<h4 id="极小连通子图："><a href="#极小连通子图：" class="headerlink" title="极小连通子图："></a>极小连通子图：</h4><p>该子图是G的连通子图，在该子图中删除任何一条边，该子图不再连通</p>
<h4 id="生成树与森林"><a href="#生成树与森林" class="headerlink" title="生成树与森林"></a>生成树与森林</h4><p><img src="https://img-blog.csdnimg.cn/20210209180911241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbmdyZW5fMTMxNA==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UuE3nm8F-1612864710815)(../AppData/Roaming/Typora/typora-user-images/1612798723552.png)]"></p>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="图的存储结构—-邻接矩阵"><a href="#图的存储结构—-邻接矩阵" class="headerlink" title="图的存储结构—-邻接矩阵"></a>图的存储结构—-邻接矩阵</h4><p>图的邻接矩阵的表示方式需要两个数组来表示图的信息，一个一维数组表示每个数据元素的信息，一个二维数组（邻接矩阵）表示图中的边或者弧的信息。</p>
<p>如果图有n个顶点，那么邻接矩阵就是一个n*n的方阵，方阵中每个元素的值的计算公式如下：<br><img src="https://img-blog.csdn.net/20170225164106193?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>邻接矩阵表示图的具体示例如下图所示：</p>
<p>首先给个无向图的实例：</p>
<p><img src="https://img-blog.csdn.net/20170225164347019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>下面是一个有向图的实例：<br><img src="https://img-blog.csdn.net/20170225165023103?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>OK，到这里为止，我们给出一个无向图的邻接矩阵和一个有向图的邻接矩阵，我们可以从这两个邻接矩阵得出一些结论：</p>
<ul>
<li>无向图的邻接矩阵都是沿对角线对称的</li>
<li>要知道无向图中某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行或（第i列）的元素之和；</li>
<li>对于有向图，要知道某个顶点的出度，其实就是这个顶点vi在邻接矩阵中第i行的元素之和，如果要知道某个顶点的入度，那就是第i列的元素之和。</li>
</ul>
<p>但是，如果我们需要表示的图是一个网的时候，例如假设有个图有n个顶点，同样该网的邻接矩阵也是一个n*n的方阵，只是方阵元素的值的计算方式不同，如下图所示：<br><img src="https://img-blog.csdn.net/20170225170217312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这里的wij表示两个顶点vi和vj边上的权值。无穷大表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值。下面是具体示例，表示的一个有向网的图和邻接矩阵：</p>
<p><img src="https://img-blog.csdn.net/20170225170847003?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdn.net/20170225200642225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="图的存储结构—-邻接矩阵的代码实现"><a href="#图的存储结构—-邻接矩阵的代码实现" class="headerlink" title="图的存储结构—-邻接矩阵的代码实现"></a>图的存储结构—-邻接矩阵的代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enum Graphkind&#123; DG, DN, UDG, UDN &#125;; //&#123;有向图，无向图，有向网，无向网&#125;</span><br><span class="line">typedef struct  Node</span><br><span class="line">&#123;</span><br><span class="line">    int * vex;  //顶点数组</span><br><span class="line">    int vexnum; //顶点个数</span><br><span class="line">    int edge;   //图的边数</span><br><span class="line">    int ** adjMatrix; //图的邻接矩阵</span><br><span class="line">    enum Graphkind kind;</span><br><span class="line">&#125;MGraph;</span><br><span class="line">void createGraph(MGraph &amp; G,enum Graphkind kind)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;输入顶点的个数&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; G.vexnum;</span><br><span class="line">    cout &lt;&lt; &quot;输入边的个数&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; G.edge;</span><br><span class="line">    //输入种类</span><br><span class="line"></span><br><span class="line">    //cout &lt;&lt; &quot;输入图的种类：DG:有向图 DN：无向图，UDG：有向网,UDN:无向网&quot; &lt;&lt; endl;</span><br><span class="line">    G.kind = kind;</span><br><span class="line">    //为两个数组开辟空间</span><br><span class="line">    G.vex = new int[G.vexnum];</span><br><span class="line">    G.adjMatrix = new int*[G.vexnum];</span><br><span class="line">    cout &lt;&lt; G.vexnum &lt;&lt; endl;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        G.adjMatrix[i] = new int[G.vexnum];</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int k = 0; k &lt; G.vexnum; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (G.kind == DG || G.kind == DN)</span><br><span class="line">            &#123;</span><br><span class="line">                G.adjMatrix[i][k] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                G.adjMatrix[i][k] = INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /*//输入每个元素的信息,这个信息，现在还不需要使用</span><br><span class="line">    for (i = 0; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; G.vex[i];</span><br><span class="line">    &#125;*/</span><br><span class="line">    cout &lt;&lt; &quot;请输入两个有关系的顶点的序号：例如：1 2 代表1号顶点指向2号顶点&quot; &lt;&lt; endl;</span><br><span class="line">    for (i = 0; i &lt; G.edge; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line">        if (G.kind == DN) &#123;</span><br><span class="line">            G.adjMatrix[b - 1][a - 1] = 1;</span><br><span class="line">            G.adjMatrix[a - 1][b - 1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (G.kind == DG)</span><br><span class="line">        &#123;</span><br><span class="line">            G.adjMatrix[a - 1][b - 1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (G.kind == UDG)</span><br><span class="line">        &#123;</span><br><span class="line">            int weight;</span><br><span class="line">            cout &lt;&lt; &quot;输入该边的权重：&quot; &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; weight;</span><br><span class="line">            G.adjMatrix[a - 1][b - 1] = weight;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            int weight;</span><br><span class="line">            cout &lt;&lt; &quot;输入该边的权重：&quot; &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; weight;</span><br><span class="line">            G.adjMatrix[b - 1][a - 1] = weight;</span><br><span class="line">            G.adjMatrix[a - 1][b - 1] = weight;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void print(MGraph g)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j = 0; j &lt; g.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (g.adjMatrix[i][j] == INT_MAX)</span><br><span class="line">                cout &lt;&lt; &quot;∞&quot; &lt;&lt; &quot; &quot;;</span><br><span class="line">            else</span><br><span class="line">            cout &lt;&lt; g.adjMatrix[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear(MGraph G)</span><br><span class="line">&#123;</span><br><span class="line">    delete G.vex;</span><br><span class="line">    G.vex = NULL;</span><br><span class="line">    for (int i = 0; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        delete G.adjMatrix[i];</span><br><span class="line">        G.adjMatrix[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    delete G.adjMatrix;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        MGraph G;</span><br><span class="line">        cout &lt;&lt; &quot;有向图例子：&quot; &lt;&lt; endl;</span><br><span class="line">        createGraph(G, DG);</span><br><span class="line">        print(G);</span><br><span class="line">        clear(G);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;无向图例子：&quot; &lt;&lt; endl;</span><br><span class="line">        createGraph(G, DN);</span><br><span class="line">        print(G);</span><br><span class="line">        clear(G);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;有向图网例子：&quot; &lt;&lt; endl;</span><br><span class="line">        createGraph(G, UDG);</span><br><span class="line">        print(G);</span><br><span class="line">        clear(G);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;无向图网例子：&quot; &lt;&lt; endl;</span><br><span class="line">        createGraph(G, UDN);</span><br><span class="line">        print(G);</span><br><span class="line">        clear(G);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：<br><img src="https://img-blog.csdn.net/20170225200807038?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="https://img-blog.csdn.net/20170225200819460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>4、图的存储结构—-邻接矩阵的优缺点</p>
<ul>
<li>优点：<br>直观、容易理解，可以很容易的判断出任意两个顶点是否有边，最大的优点就是很容易计算出各个顶点的度。</li>
<li>缺点：<br>当我么表示完全图的时候，邻接矩阵是最好的表示方法，但是对于稀疏矩阵，由于它边少，但是顶点多，这样就会造成空间的浪费。</li>
</ul>
<h4 id="图的存储结构—邻接表"><a href="#图的存储结构—邻接表" class="headerlink" title="图的存储结构—邻接表"></a>图的存储结构—邻接表</h4><p>邻接表是图的一种链式存储结构。主要是应对于邻接矩阵在顶点多边少的时候，浪费空间的问题。它的方法就是声明两个结构。如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20170226103426439?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>OK，我们虽然知道了邻接表是这两个结构来表示图的，那么它的怎么表示的了，不急，我们先把它转为c++代码先，然后，再给个示例，你就明白了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef char Vertextype;</span><br><span class="line">//表结点结构</span><br><span class="line">struct ArcNode &#123;</span><br><span class="line">    int adjvex;   //某条边指向的那个顶点的位置（一般是数组的下标）。</span><br><span class="line">    ArcNode * nextarc; //指向下一个表结点</span><br><span class="line">    int weight;   //这个只有网图才需要使用。普通的图可以直接忽略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//头结点</span><br><span class="line">struct Vnode</span><br><span class="line">&#123;</span><br><span class="line">    Vertextype data;  //这个是记录每个顶点的信息（现在一般都不需要怎么使用）</span><br><span class="line">    ArcNode * firstarc; //指向第一条依附在该顶点边的信息（表结点）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>无向图的示例：</p>
<p><img src="https://img-blog.csdn.net/20170226104025425?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>从图中我们可以知道，顶点是通过一个头结点类型的一维数组来保存的，其中我们每个头结点的firstarc都是指向第一条依附在该顶点边的信息，表结点的adjvex表示的该边的另外一个顶点在顶点数组中的下标，weight域对于普通图是无意义的，可以忽略，nextarc指向的是下一条依附在该顶点的边的信息。<br>下面再给出一个有向图的例子：<br><img src="https://img-blog.csdn.net/20170226104838359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>通过上述的两个例子，我们应该明白邻接表是如何进行表示图的信息的了。</p>
<h4 id="图的存储结构—-邻接表的代码实现"><a href="#图的存储结构—-邻接表的代码实现" class="headerlink" title="图的存储结构—-邻接表的代码实现"></a>图的存储结构—-邻接表的代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef string Vertextype;</span><br><span class="line">//表结点结构</span><br><span class="line">struct ArcNode &#123;</span><br><span class="line">    int adjvex;   //某条边指向的那个顶点的位置（一般是数组的下标）。</span><br><span class="line">    ArcNode * nextarc; //指向下一个表结点</span><br><span class="line">    int weight;   //这个只有网图才需要使用。</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//头结点</span><br><span class="line">struct Vnode</span><br><span class="line">&#123;</span><br><span class="line">    Vertextype data;  //这个是记录每个顶点的信息（现在一般都不需要怎么使用）</span><br><span class="line">    ArcNode * firstarc; //指向第一条依附在该顶点边的信息（表结点）</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">struct Graph</span><br><span class="line">&#123;</span><br><span class="line">    int kind;  //图的种类(有向图：0,无向图：1，有向网：2，无向网：3)</span><br><span class="line">    int vexnum; //图的顶点数</span><br><span class="line">    int edge;  //图的边数</span><br><span class="line">    Vnode * node; //图的（顶点）头结点数组</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void createGraph(Graph &amp; g,int kind)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;请输入顶点的个数：&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; g.vexnum;</span><br><span class="line">    cout &lt;&lt; &quot;请输入边的个数（无向图/网要乘2）：&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; g.edge;</span><br><span class="line">    g.kind = kind; //决定图的种类</span><br><span class="line">    g.node = new Vnode[g.vexnum];</span><br><span class="line">    int i;</span><br><span class="line">    cout &lt;&lt; &quot;输入每个顶点的信息：&quot; &lt;&lt; endl;//记录每个顶点的信息</span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; g.node[i].data;</span><br><span class="line">        g.node[i].firstarc=NULL;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;请输入每条边的起点和终点的编号：&quot; &lt;&lt; endl;</span><br><span class="line">    for (i = 0; i &lt; g.edge; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a;</span><br><span class="line">        int b;</span><br><span class="line">        cin &gt;&gt; a; //起点</span><br><span class="line">        cin &gt;&gt; b; //终点</span><br><span class="line">        ArcNode * next=new ArcNode;</span><br><span class="line">        next-&gt;adjvex = b - 1;</span><br><span class="line">        if(kind==0 || kind==1)</span><br><span class="line">        next-&gt;weight = -1;</span><br><span class="line">        else &#123;//如果是网图，还需要权重</span><br><span class="line">            cout &lt;&lt; &quot;输入该边的权重：&quot; &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; next-&gt;weight;</span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;nextarc = NULL;</span><br><span class="line"></span><br><span class="line">        //将边串联起来</span><br><span class="line">        if (g.node[a - 1].firstarc == NULL) &#123;</span><br><span class="line">            g.node[a - 1].firstarc=next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            ArcNode * p;</span><br><span class="line">            p = g.node[a - 1].firstarc;</span><br><span class="line">            while (p-&gt;nextarc)//找到该链表的最后一个表结点</span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;nextarc;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;nextarc = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(Graph  g)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    cout &lt;&lt; &quot;图的邻接表为：&quot; &lt;&lt; endl;</span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; g.node[i].data&lt;&lt;&quot; &quot;;</span><br><span class="line">        ArcNode * now;</span><br><span class="line">        now = g.node[i].firstarc;</span><br><span class="line">        while (now)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; now-&gt;adjvex &lt;&lt; &quot; &quot;;</span><br><span class="line">            now = now-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Graph g;</span><br><span class="line">    cout &lt;&lt; &quot;有向图的例子&quot; &lt;&lt; endl;</span><br><span class="line">    createGraph(g,0);</span><br><span class="line">    print(g);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;无向图的例子&quot; &lt;&lt; endl;</span><br><span class="line">    createGraph(g, 1);</span><br><span class="line">    print(g);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：<br><img src="https://img-blog.csdn.net/20170226144656132?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> <img src="https://img-blog.csdn.net/20170226144714468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="图的存储结构—-邻接表的优缺点"><a href="#图的存储结构—-邻接表的优缺点" class="headerlink" title="图的存储结构—-邻接表的优缺点"></a>图的存储结构—-邻接表的优缺点</h4><ul>
<li>优点：<br>对于，稀疏图，邻接表比邻接矩阵更节约空间。</li>
<li>缺点：<br>不容易判断两个顶点是有关系（边），顶点的出度容易，但是求入度需要遍历整个邻接表。</li>
</ul>
<h4 id="有向图的存储结构—-十字链表"><a href="#有向图的存储结构—-十字链表" class="headerlink" title="有向图的存储结构—-十字链表"></a>有向图的存储结构—-十字链表</h4><p>十字链表是有向图的一个专有的链表结构，我们之前也说了，邻接表对于我们计算顶点的入度是一个很麻烦的事情，而十字链表正好可以解决这个问题。十字链表和邻接表一样，他会有两个结构来表示图：其中一个结构用于保存顶点信息，另外一个结构是用于保存每条边的信息，如下图所示：<br><img src="https://img-blog.csdn.net/20170226164845621?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>同样，我们知道头结点就是用于保存每个顶点信息的结构，其中data主要是保存顶点的信息（如顶点的名称），firstin是保存第一个入度的边的信息，firstout保存第一个出度的边的信息。其中，表结点就是记录每条边的信息，其中tailvex是记录这条边弧头的顶点的在顶点表中的下标（不是箭头那个），headvex则是记录弧尾对应的那个顶点在顶点表中的下标（箭头的那个），hlink是指向具有下一个具有相同的headvex的表结点，tlink指向具有相同的tailvex的表结点，weight是表示边的权重（网图才需要使用）。具体的代码表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef string Vertextype;</span><br><span class="line">//表结点结构</span><br><span class="line">struct ArcNode &#123;</span><br><span class="line">    int tailvex;   //弧尾的下标，一般都是和对应的头结点下标相同</span><br><span class="line">    int headvex;   //弧头的下标</span><br><span class="line">    ArcNode * hlink; //指向下一个弧头同为headvex的表结点 ，边是箭头的那边</span><br><span class="line">    ArcNode * tlink;  //指向下一个弧尾为tailvex的表结点,边不是箭头的那边</span><br><span class="line">    int weight;  //只有网才会用这个变量</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//头结点</span><br><span class="line">struct Vnode</span><br><span class="line">&#123;</span><br><span class="line">    Vertextype data;  //这个是记录每个顶点的信息（现在一般都不需要怎么使用）</span><br><span class="line">    ArcNode *firstin; //指向第一条（入度）在该顶点的表结点</span><br><span class="line">    ArcNode *firstout; //指向第一条（出度）在该顶点的表结点</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面，我们给出一个有向图的十字链表的例子：<br><img src="https://img-blog.csdn.net/20170226171332169?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>其实，这个自己也可以去尝试手画一个十字链表出来，其实都是很简单的</p>
<h4 id="有向图的存储结构—-十字链表代码实现"><a href="#有向图的存储结构—-十字链表代码实现" class="headerlink" title="有向图的存储结构—-十字链表代码实现"></a>有向图的存储结构—-十字链表代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef string Vertextype;</span><br><span class="line">//表结点结构</span><br><span class="line">struct ArcNode &#123;</span><br><span class="line">    int tailvex;   //弧尾的下标，一般都是和对应的头结点下标相同</span><br><span class="line">    int headvex;   //弧头的下标</span><br><span class="line">    ArcNode * hlink; //指向下一个弧头同为headvex的表结点 ，边是箭头的那边</span><br><span class="line">    ArcNode * tlink;  //指向下一个弧尾为tailvex的表结点,边不是箭头的那边</span><br><span class="line">    int weight;  //只有网才会用这个变量</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//头结点</span><br><span class="line">struct Vnode</span><br><span class="line">&#123;</span><br><span class="line">    Vertextype data;  //这个是记录每个顶点的信息（现在一般都不需要怎么使用）</span><br><span class="line">    ArcNode *firstin; //指向第一条（入度）在该顶点的表结点</span><br><span class="line">    ArcNode *firstout; //指向第一条（出度）在该顶点的表结点</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Graph</span><br><span class="line">&#123;</span><br><span class="line">    int kind;  //图的种类(有向图：0，有向网：1)</span><br><span class="line">    int vexnum; //图的顶点数</span><br><span class="line">    int edge;  //图的边数</span><br><span class="line">    Vnode * node; //图的（顶点）头结点数组</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void createGraph(Graph &amp; g,int kind)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;请输入顶点的个数：&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; g.vexnum;</span><br><span class="line">    cout &lt;&lt; &quot;请输入边的个数（无向图/网要乘2）：&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; g.edge;</span><br><span class="line">    g.kind = kind; //决定图的种类</span><br><span class="line">    g.node = new Vnode[g.vexnum];</span><br><span class="line">    int i;</span><br><span class="line">    cout &lt;&lt; &quot;输入每个顶点的信息：&quot; &lt;&lt; endl;//记录每个顶点的信息</span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; g.node[i].data;</span><br><span class="line">        g.node[i].firstin = NULL;</span><br><span class="line">        g.node[i].firstout = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;请输入每条边的起点和终点的编号：&quot; &lt;&lt; endl;</span><br><span class="line">    for (i = 0; i &lt; g.edge; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">        ArcNode * next = new ArcNode;</span><br><span class="line">        next-&gt;tailvex = a - 1; //首先是弧头的下标</span><br><span class="line">        next-&gt; headvex = b - 1; //弧尾的下标</span><br><span class="line">        //只有网图需要权重信息</span><br><span class="line">        if(kind==0)</span><br><span class="line">        next-&gt;weight = -1;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;输入该边的权重：&quot; &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; next-&gt;weight;</span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;tlink = NULL;</span><br><span class="line">        next-&gt;hlink = NULL;</span><br><span class="line">        //该位置的顶点的出度还为空时，直接让你fisrstout指针指向新的表结点</span><br><span class="line">        //记录的出度信息</span><br><span class="line">        if (g.node[a - 1].firstout == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            g.node[a - 1].firstout = next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ArcNode * now;</span><br><span class="line">            now = g.node[a - 1].firstout;</span><br><span class="line">            while (now-&gt;tlink)</span><br><span class="line">            &#123;</span><br><span class="line">                now = now-&gt;tlink;</span><br><span class="line">            &#125;</span><br><span class="line">            now-&gt;tlink = next;</span><br><span class="line">        &#125;</span><br><span class="line">        //记录某个顶点的入度信息</span><br><span class="line">        if (g.node[b - 1].firstin == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            g.node[b - 1].firstin = next;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ArcNode * now;</span><br><span class="line">            now = g.node[b - 1].firstin;</span><br><span class="line">            while (now-&gt;hlink)//找到最后一个表结点</span><br><span class="line">            &#123;</span><br><span class="line">                now = now-&gt;hlink;</span><br><span class="line">            &#125;</span><br><span class="line">            now-&gt;hlink = next;//更新最后一个表结点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(Graph g)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    cout &lt;&lt; &quot;各个顶点的出度信息&quot; &lt;&lt; endl;</span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; g.node[i].data &lt;&lt; &quot; &quot;;</span><br><span class="line">        ArcNode * now;</span><br><span class="line">        now = g.node[i].firstout;</span><br><span class="line">        while (now)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; now-&gt;headvex &lt;&lt; &quot; &quot;;</span><br><span class="line">            now = now-&gt;tlink;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;^&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;各个顶点的入度信息&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; g.node[i].data &lt;&lt; &quot; &quot;;</span><br><span class="line">        ArcNode * now;</span><br><span class="line">        now = g.node[i].firstin;</span><br><span class="line">        while (now)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; now-&gt;tailvex &lt;&lt; &quot; &quot;;</span><br><span class="line">            now = now-&gt;hlink;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;^&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Graph g;</span><br><span class="line">    cout &lt;&lt; &quot;有向图的例子&quot; &lt;&lt; endl;</span><br><span class="line">    createGraph(g, 0);</span><br><span class="line">    print(g);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20170226171617219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="无向图的存储结构—-邻接多重表"><a href="#无向图的存储结构—-邻接多重表" class="headerlink" title="无向图的存储结构—-邻接多重表"></a>无向图的存储结构—-邻接多重表</h4><p>邻接多重表是无向图的另一种链式存储结构。我们之前也说了使用邻接矩阵来存储图比价浪费空间，但是如果我们使用邻接表来存储图时，对于无向图又有一些不便的地方，例如我们需要对一条已经访问过的边进行删除或者标记等操作时，我们除了需要找到表示同一条边的两个结点。这会给我们的程序执行效率大打折扣，所以这个时候，邻接多重表就派上用场啦。</p>
<p>首先，邻接多重表同样是对邻接表的一个改进得到来的结构，它同样需要一个头结点保存每个顶点的信息和一个表结点，保存每条边的信息，他们的结构如下：<br><img src="https://img-blog.csdn.net/20170227144216870?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>其中，头结点的结构和邻接表一样，而表结点中就改变比较大了，其中mark为标志域，例如标志是否已经访问过，ivex和jvex代表边的两个顶点在顶点表中的下标，ilink指向下一个依附在顶点ivex的边，jlink指向下一个依附在顶点jvex的边，weight在网图的时候使用，代表该边的权重。</p>
<p>下面是一个无向图的邻接多重表的实例（自己也可以尝试去画画，具体的原理都是很简单的）：<br><img src="https://img-blog.csdn.net/20170227151046657?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="无向图的存储结构—-邻接多重表代码实现"><a href="#无向图的存储结构—-邻接多重表代码实现" class="headerlink" title="无向图的存储结构—-邻接多重表代码实现"></a>无向图的存储结构—-邻接多重表代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//表结点</span><br><span class="line">struct ArcNode</span><br><span class="line">&#123;</span><br><span class="line">    int mark; //标志位</span><br><span class="line">    int ivex; //输入边信息的那个起点</span><br><span class="line">    ArcNode * ilink; //依附在顶点ivex的下一条边的信息</span><br><span class="line">    int jvex;   //输入边信息的那个终点</span><br><span class="line">    ArcNode * jlink; //依附在顶点jvex的下一条边的信息</span><br><span class="line">    int weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//头结点</span><br><span class="line">struct VexNode &#123;</span><br><span class="line">    string data;   //顶点的信息，如顶点名称</span><br><span class="line">    ArcNode * firstedge; //第一条依附顶点的边</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Graph &#123;</span><br><span class="line">    int vexnum;   //顶点的个数</span><br><span class="line">    int edge;    //边的个数</span><br><span class="line">    VexNode *node; //保存顶点信息</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void createGraph(Graph &amp; g)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;请输入顶点的个数：&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; g.vexnum;</span><br><span class="line">    cout &lt;&lt; &quot;请输入边的个数（无向图/网要乘2）：&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; g.edge;</span><br><span class="line">    g.node = new VexNode[g.vexnum];</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line">    cout &lt;&lt; &quot;输入每个顶点的信息：&quot; &lt;&lt; endl;//记录每个顶点的信息</span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; g.node[i].data;</span><br><span class="line">        g.node[i].firstedge = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;请输入每条边的起点和终点的编号：&quot; &lt;&lt; endl;</span><br><span class="line">    for (i = 0; i &lt; g.edge; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">        ArcNode * next = new ArcNode;</span><br><span class="line">        next-&gt;mark = 0;</span><br><span class="line">        next-&gt;ivex = a - 1; //首先是弧头的下标</span><br><span class="line">        next-&gt;jvex = b - 1; //弧尾的下标</span><br><span class="line">        next-&gt;weight = -1;</span><br><span class="line">        next-&gt;ilink = NULL;</span><br><span class="line">        next-&gt;jlink = NULL;</span><br><span class="line"></span><br><span class="line">        //更新顶点表a-1的信息</span><br><span class="line">        if (g.node[a - 1].firstedge == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            g.node[a - 1].firstedge = next;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ArcNode * now;</span><br><span class="line">            now = g.node[a - 1].firstedge;</span><br><span class="line">            while (1) &#123;</span><br><span class="line">                if (now-&gt;ivex == (a - 1) &amp;&amp; now-&gt;ilink == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    now-&gt;ilink = next;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (now-&gt;ivex == (a - 1) &amp;&amp; now-&gt;ilink != NULL) &#123;</span><br><span class="line">                    now = now-&gt;ilink;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (now-&gt;jvex == (a - 1) &amp;&amp; now-&gt;jlink == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    now-&gt;jlink = next;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (now-&gt;jvex == (a - 1) &amp;&amp; now-&gt;jlink != NULL) &#123;</span><br><span class="line">                    now = now-&gt;jlink;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //更新顶点表b-1</span><br><span class="line">        if (g.node[b - 1].firstedge == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            g.node[b - 1].firstedge = next;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ArcNode * now;</span><br><span class="line">            now = g.node[b - 1].firstedge;</span><br><span class="line">            while (1) &#123;</span><br><span class="line">                if (now-&gt;ivex == (b - 1) &amp;&amp; now-&gt;ilink == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    now-&gt;ilink = next;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (now-&gt;ivex == (b - 1) &amp;&amp; now-&gt;ilink != NULL) &#123;</span><br><span class="line">                    now = now-&gt;ilink;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (now-&gt;jvex == (b - 1) &amp;&amp; now-&gt;jlink == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    now-&gt;jlink = next;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (now-&gt;jvex == (b - 1) &amp;&amp; now-&gt;jlink != NULL) &#123;</span><br><span class="line">                    now = now-&gt;jlink;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(Graph g)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; g.node[i].data &lt;&lt; &quot; &quot;;</span><br><span class="line">        ArcNode * now;</span><br><span class="line">        now = g.node[i].firstedge;</span><br><span class="line">        while (now)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;ivex=&quot; &lt;&lt; now-&gt;ivex &lt;&lt; &quot; jvex=&quot; &lt;&lt; now-&gt;jvex &lt;&lt; &quot; &quot;;</span><br><span class="line">            if (now-&gt;ivex == i)</span><br><span class="line">            &#123;</span><br><span class="line">                now = now-&gt;ilink;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (now-&gt;jvex == i)</span><br><span class="line">            &#123;</span><br><span class="line">                now = now-&gt;jlink;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Graph g;</span><br><span class="line">    createGraph(g);</span><br><span class="line">    print(g);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：<br><img src="https://img-blog.csdn.net/20170227155439125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>来源（<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35644234/article/details/57083107%EF%BC%89###">https://blog.csdn.net/qq_35644234/article/details/57083107）###</a> 图的存储结构</p>
<h4 id="图的存储结构—-邻接矩阵-1"><a href="#图的存储结构—-邻接矩阵-1" class="headerlink" title="图的存储结构—-邻接矩阵"></a>图的存储结构—-邻接矩阵</h4><p>图的邻接矩阵的表示方式需要两个数组来表示图的信息，一个一维数组表示每个数据元素的信息，一个二维数组（邻接矩阵）表示图中的边或者弧的信息。</p>
<p>如果图有n个顶点，那么邻接矩阵就是一个n*n的方阵，方阵中每个元素的值的计算公式如下：<br><img src="https://img-blog.csdn.net/20170225164106193?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>邻接矩阵表示图的具体示例如下图所示：</p>
<p>首先给个无向图的实例：</p>
<p><img src="https://img-blog.csdn.net/20170225164347019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>下面是一个有向图的实例：<br><img src="https://img-blog.csdn.net/20170225165023103?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>OK，到这里为止，我们给出一个无向图的邻接矩阵和一个有向图的邻接矩阵，我们可以从这两个邻接矩阵得出一些结论：</p>
<ul>
<li>无向图的邻接矩阵都是沿对角线对称的</li>
<li>要知道无向图中某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行或（第i列）的元素之和；</li>
<li>对于有向图，要知道某个顶点的出度，其实就是这个顶点vi在邻接矩阵中第i行的元素之和，如果要知道某个顶点的入度，那就是第i列的元素之和。</li>
</ul>
<p>但是，如果我们需要表示的图是一个网的时候，例如假设有个图有n个顶点，同样该网的邻接矩阵也是一个n*n的方阵，只是方阵元素的值的计算方式不同，如下图所示：<br><img src="https://img-blog.csdn.net/20170225170217312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这里的wij表示两个顶点vi和vj边上的权值。无穷大表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值。下面是具体示例，表示的一个有向网的图和邻接矩阵：</p>
<p><img src="https://img-blog.csdn.net/20170225170847003?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdn.net/20170225200642225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="图的存储结构—-邻接矩阵的代码实现-1"><a href="#图的存储结构—-邻接矩阵的代码实现-1" class="headerlink" title="图的存储结构—-邻接矩阵的代码实现"></a>图的存储结构—-邻接矩阵的代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enum Graphkind&#123; DG, DN, UDG, UDN &#125;; //&#123;有向图，无向图，有向网，无向网&#125;</span><br><span class="line">typedef struct  Node</span><br><span class="line">&#123;</span><br><span class="line">    int * vex;  //顶点数组</span><br><span class="line">    int vexnum; //顶点个数</span><br><span class="line">    int edge;   //图的边数</span><br><span class="line">    int ** adjMatrix; //图的邻接矩阵</span><br><span class="line">    enum Graphkind kind;</span><br><span class="line">&#125;MGraph;</span><br><span class="line">void createGraph(MGraph &amp; G,enum Graphkind kind)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;输入顶点的个数&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; G.vexnum;</span><br><span class="line">    cout &lt;&lt; &quot;输入边的个数&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; G.edge;</span><br><span class="line">    //输入种类</span><br><span class="line"></span><br><span class="line">    //cout &lt;&lt; &quot;输入图的种类：DG:有向图 DN：无向图，UDG：有向网,UDN:无向网&quot; &lt;&lt; endl;</span><br><span class="line">    G.kind = kind;</span><br><span class="line">    //为两个数组开辟空间</span><br><span class="line">    G.vex = new int[G.vexnum];</span><br><span class="line">    G.adjMatrix = new int*[G.vexnum];</span><br><span class="line">    cout &lt;&lt; G.vexnum &lt;&lt; endl;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        G.adjMatrix[i] = new int[G.vexnum];</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int k = 0; k &lt; G.vexnum; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (G.kind == DG || G.kind == DN)</span><br><span class="line">            &#123;</span><br><span class="line">                G.adjMatrix[i][k] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                G.adjMatrix[i][k] = INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /*//输入每个元素的信息,这个信息，现在还不需要使用</span><br><span class="line">    for (i = 0; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; G.vex[i];</span><br><span class="line">    &#125;*/</span><br><span class="line">    cout &lt;&lt; &quot;请输入两个有关系的顶点的序号：例如：1 2 代表1号顶点指向2号顶点&quot; &lt;&lt; endl;</span><br><span class="line">    for (i = 0; i &lt; G.edge; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line">        if (G.kind == DN) &#123;</span><br><span class="line">            G.adjMatrix[b - 1][a - 1] = 1;</span><br><span class="line">            G.adjMatrix[a - 1][b - 1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (G.kind == DG)</span><br><span class="line">        &#123;</span><br><span class="line">            G.adjMatrix[a - 1][b - 1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (G.kind == UDG)</span><br><span class="line">        &#123;</span><br><span class="line">            int weight;</span><br><span class="line">            cout &lt;&lt; &quot;输入该边的权重：&quot; &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; weight;</span><br><span class="line">            G.adjMatrix[a - 1][b - 1] = weight;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            int weight;</span><br><span class="line">            cout &lt;&lt; &quot;输入该边的权重：&quot; &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; weight;</span><br><span class="line">            G.adjMatrix[b - 1][a - 1] = weight;</span><br><span class="line">            G.adjMatrix[a - 1][b - 1] = weight;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void print(MGraph g)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j = 0; j &lt; g.vexnum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (g.adjMatrix[i][j] == INT_MAX)</span><br><span class="line">                cout &lt;&lt; &quot;∞&quot; &lt;&lt; &quot; &quot;;</span><br><span class="line">            else</span><br><span class="line">            cout &lt;&lt; g.adjMatrix[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear(MGraph G)</span><br><span class="line">&#123;</span><br><span class="line">    delete G.vex;</span><br><span class="line">    G.vex = NULL;</span><br><span class="line">    for (int i = 0; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        delete G.adjMatrix[i];</span><br><span class="line">        G.adjMatrix[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    delete G.adjMatrix;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        MGraph G;</span><br><span class="line">        cout &lt;&lt; &quot;有向图例子：&quot; &lt;&lt; endl;</span><br><span class="line">        createGraph(G, DG);</span><br><span class="line">        print(G);</span><br><span class="line">        clear(G);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;无向图例子：&quot; &lt;&lt; endl;</span><br><span class="line">        createGraph(G, DN);</span><br><span class="line">        print(G);</span><br><span class="line">        clear(G);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;有向图网例子：&quot; &lt;&lt; endl;</span><br><span class="line">        createGraph(G, UDG);</span><br><span class="line">        print(G);</span><br><span class="line">        clear(G);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;无向图网例子：&quot; &lt;&lt; endl;</span><br><span class="line">        createGraph(G, UDN);</span><br><span class="line">        print(G);</span><br><span class="line">        clear(G);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：<br><img src="https://img-blog.csdn.net/20170225200807038?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><img src="https://img-blog.csdn.net/20170225200819460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>4、图的存储结构—-邻接矩阵的优缺点</p>
<ul>
<li>优点：<br>直观、容易理解，可以很容易的判断出任意两个顶点是否有边，最大的优点就是很容易计算出各个顶点的度。</li>
<li>缺点：<br>当我么表示完全图的时候，邻接矩阵是最好的表示方法，但是对于稀疏矩阵，由于它边少，但是顶点多，这样就会造成空间的浪费。</li>
</ul>
<h4 id="图的存储结构—邻接表-1"><a href="#图的存储结构—邻接表-1" class="headerlink" title="图的存储结构—邻接表"></a>图的存储结构—邻接表</h4><p>邻接表是图的一种链式存储结构。主要是应对于邻接矩阵在顶点多边少的时候，浪费空间的问题。它的方法就是声明两个结构。如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20170226103426439?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>OK，我们虽然知道了邻接表是这两个结构来表示图的，那么它的怎么表示的了，不急，我们先把它转为c++代码先，然后，再给个示例，你就明白了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef char Vertextype;</span><br><span class="line">//表结点结构</span><br><span class="line">struct ArcNode &#123;</span><br><span class="line">    int adjvex;   //某条边指向的那个顶点的位置（一般是数组的下标）。</span><br><span class="line">    ArcNode * nextarc; //指向下一个表结点</span><br><span class="line">    int weight;   //这个只有网图才需要使用。普通的图可以直接忽略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//头结点</span><br><span class="line">struct Vnode</span><br><span class="line">&#123;</span><br><span class="line">    Vertextype data;  //这个是记录每个顶点的信息（现在一般都不需要怎么使用）</span><br><span class="line">    ArcNode * firstarc; //指向第一条依附在该顶点边的信息（表结点）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>无向图的示例：</p>
<p><img src="https://img-blog.csdn.net/20170226104025425?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>从图中我们可以知道，顶点是通过一个头结点类型的一维数组来保存的，其中我们每个头结点的firstarc都是指向第一条依附在该顶点边的信息，表结点的adjvex表示的该边的另外一个顶点在顶点数组中的下标，weight域对于普通图是无意义的，可以忽略，nextarc指向的是下一条依附在该顶点的边的信息。<br>下面再给出一个有向图的例子：<br><img src="https://img-blog.csdn.net/20170226104838359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>通过上述的两个例子，我们应该明白邻接表是如何进行表示图的信息的了。</p>
<h4 id="图的存储结构—-邻接表的代码实现-1"><a href="#图的存储结构—-邻接表的代码实现-1" class="headerlink" title="图的存储结构—-邻接表的代码实现"></a>图的存储结构—-邻接表的代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef string Vertextype;</span><br><span class="line">//表结点结构</span><br><span class="line">struct ArcNode &#123;</span><br><span class="line">    int adjvex;   //某条边指向的那个顶点的位置（一般是数组的下标）。</span><br><span class="line">    ArcNode * nextarc; //指向下一个表结点</span><br><span class="line">    int weight;   //这个只有网图才需要使用。</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//头结点</span><br><span class="line">struct Vnode</span><br><span class="line">&#123;</span><br><span class="line">    Vertextype data;  //这个是记录每个顶点的信息（现在一般都不需要怎么使用）</span><br><span class="line">    ArcNode * firstarc; //指向第一条依附在该顶点边的信息（表结点）</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">struct Graph</span><br><span class="line">&#123;</span><br><span class="line">    int kind;  //图的种类(有向图：0,无向图：1，有向网：2，无向网：3)</span><br><span class="line">    int vexnum; //图的顶点数</span><br><span class="line">    int edge;  //图的边数</span><br><span class="line">    Vnode * node; //图的（顶点）头结点数组</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void createGraph(Graph &amp; g,int kind)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;请输入顶点的个数：&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; g.vexnum;</span><br><span class="line">    cout &lt;&lt; &quot;请输入边的个数（无向图/网要乘2）：&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; g.edge;</span><br><span class="line">    g.kind = kind; //决定图的种类</span><br><span class="line">    g.node = new Vnode[g.vexnum];</span><br><span class="line">    int i;</span><br><span class="line">    cout &lt;&lt; &quot;输入每个顶点的信息：&quot; &lt;&lt; endl;//记录每个顶点的信息</span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; g.node[i].data;</span><br><span class="line">        g.node[i].firstarc=NULL;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;请输入每条边的起点和终点的编号：&quot; &lt;&lt; endl;</span><br><span class="line">    for (i = 0; i &lt; g.edge; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a;</span><br><span class="line">        int b;</span><br><span class="line">        cin &gt;&gt; a; //起点</span><br><span class="line">        cin &gt;&gt; b; //终点</span><br><span class="line">        ArcNode * next=new ArcNode;</span><br><span class="line">        next-&gt;adjvex = b - 1;</span><br><span class="line">        if(kind==0 || kind==1)</span><br><span class="line">        next-&gt;weight = -1;</span><br><span class="line">        else &#123;//如果是网图，还需要权重</span><br><span class="line">            cout &lt;&lt; &quot;输入该边的权重：&quot; &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; next-&gt;weight;</span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;nextarc = NULL;</span><br><span class="line"></span><br><span class="line">        //将边串联起来</span><br><span class="line">        if (g.node[a - 1].firstarc == NULL) &#123;</span><br><span class="line">            g.node[a - 1].firstarc=next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            ArcNode * p;</span><br><span class="line">            p = g.node[a - 1].firstarc;</span><br><span class="line">            while (p-&gt;nextarc)//找到该链表的最后一个表结点</span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;nextarc;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;nextarc = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(Graph  g)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    cout &lt;&lt; &quot;图的邻接表为：&quot; &lt;&lt; endl;</span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; g.node[i].data&lt;&lt;&quot; &quot;;</span><br><span class="line">        ArcNode * now;</span><br><span class="line">        now = g.node[i].firstarc;</span><br><span class="line">        while (now)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; now-&gt;adjvex &lt;&lt; &quot; &quot;;</span><br><span class="line">            now = now-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Graph g;</span><br><span class="line">    cout &lt;&lt; &quot;有向图的例子&quot; &lt;&lt; endl;</span><br><span class="line">    createGraph(g,0);</span><br><span class="line">    print(g);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;无向图的例子&quot; &lt;&lt; endl;</span><br><span class="line">    createGraph(g, 1);</span><br><span class="line">    print(g);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：<br><img src="https://img-blog.csdn.net/20170226144656132?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> <img src="https://img-blog.csdn.net/20170226144714468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="图的存储结构—-邻接表的优缺点-1"><a href="#图的存储结构—-邻接表的优缺点-1" class="headerlink" title="图的存储结构—-邻接表的优缺点"></a>图的存储结构—-邻接表的优缺点</h4><ul>
<li>优点：<br>对于，稀疏图，邻接表比邻接矩阵更节约空间。</li>
<li>缺点：<br>不容易判断两个顶点是有关系（边），顶点的出度容易，但是求入度需要遍历整个邻接表。</li>
</ul>
<h4 id="有向图的存储结构—-十字链表-1"><a href="#有向图的存储结构—-十字链表-1" class="headerlink" title="有向图的存储结构—-十字链表"></a>有向图的存储结构—-十字链表</h4><p>十字链表是有向图的一个专有的链表结构，我们之前也说了，邻接表对于我们计算顶点的入度是一个很麻烦的事情，而十字链表正好可以解决这个问题。十字链表和邻接表一样，他会有两个结构来表示图：其中一个结构用于保存顶点信息，另外一个结构是用于保存每条边的信息，如下图所示：<br><img src="https://img-blog.csdn.net/20170226164845621?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>同样，我们知道头结点就是用于保存每个顶点信息的结构，其中data主要是保存顶点的信息（如顶点的名称），firstin是保存第一个入度的边的信息，firstout保存第一个出度的边的信息。其中，表结点就是记录每条边的信息，其中tailvex是记录这条边弧头的顶点的在顶点表中的下标（不是箭头那个），headvex则是记录弧尾对应的那个顶点在顶点表中的下标（箭头的那个），hlink是指向具有下一个具有相同的headvex的表结点，tlink指向具有相同的tailvex的表结点，weight是表示边的权重（网图才需要使用）。具体的代码表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef string Vertextype;</span><br><span class="line">//表结点结构</span><br><span class="line">struct ArcNode &#123;</span><br><span class="line">    int tailvex;   //弧尾的下标，一般都是和对应的头结点下标相同</span><br><span class="line">    int headvex;   //弧头的下标</span><br><span class="line">    ArcNode * hlink; //指向下一个弧头同为headvex的表结点 ，边是箭头的那边</span><br><span class="line">    ArcNode * tlink;  //指向下一个弧尾为tailvex的表结点,边不是箭头的那边</span><br><span class="line">    int weight;  //只有网才会用这个变量</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//头结点</span><br><span class="line">struct Vnode</span><br><span class="line">&#123;</span><br><span class="line">    Vertextype data;  //这个是记录每个顶点的信息（现在一般都不需要怎么使用）</span><br><span class="line">    ArcNode *firstin; //指向第一条（入度）在该顶点的表结点</span><br><span class="line">    ArcNode *firstout; //指向第一条（出度）在该顶点的表结点</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面，我们给出一个有向图的十字链表的例子：<br><img src="https://img-blog.csdn.net/20170226171332169?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>其实，这个自己也可以去尝试手画一个十字链表出来，其实都是很简单的</p>
<h4 id="有向图的存储结构—-十字链表代码实现-1"><a href="#有向图的存储结构—-十字链表代码实现-1" class="headerlink" title="有向图的存储结构—-十字链表代码实现"></a>有向图的存储结构—-十字链表代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef string Vertextype;</span><br><span class="line">//表结点结构</span><br><span class="line">struct ArcNode &#123;</span><br><span class="line">    int tailvex;   //弧尾的下标，一般都是和对应的头结点下标相同</span><br><span class="line">    int headvex;   //弧头的下标</span><br><span class="line">    ArcNode * hlink; //指向下一个弧头同为headvex的表结点 ，边是箭头的那边</span><br><span class="line">    ArcNode * tlink;  //指向下一个弧尾为tailvex的表结点,边不是箭头的那边</span><br><span class="line">    int weight;  //只有网才会用这个变量</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//头结点</span><br><span class="line">struct Vnode</span><br><span class="line">&#123;</span><br><span class="line">    Vertextype data;  //这个是记录每个顶点的信息（现在一般都不需要怎么使用）</span><br><span class="line">    ArcNode *firstin; //指向第一条（入度）在该顶点的表结点</span><br><span class="line">    ArcNode *firstout; //指向第一条（出度）在该顶点的表结点</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Graph</span><br><span class="line">&#123;</span><br><span class="line">    int kind;  //图的种类(有向图：0，有向网：1)</span><br><span class="line">    int vexnum; //图的顶点数</span><br><span class="line">    int edge;  //图的边数</span><br><span class="line">    Vnode * node; //图的（顶点）头结点数组</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void createGraph(Graph &amp; g,int kind)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;请输入顶点的个数：&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; g.vexnum;</span><br><span class="line">    cout &lt;&lt; &quot;请输入边的个数（无向图/网要乘2）：&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; g.edge;</span><br><span class="line">    g.kind = kind; //决定图的种类</span><br><span class="line">    g.node = new Vnode[g.vexnum];</span><br><span class="line">    int i;</span><br><span class="line">    cout &lt;&lt; &quot;输入每个顶点的信息：&quot; &lt;&lt; endl;//记录每个顶点的信息</span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; g.node[i].data;</span><br><span class="line">        g.node[i].firstin = NULL;</span><br><span class="line">        g.node[i].firstout = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;请输入每条边的起点和终点的编号：&quot; &lt;&lt; endl;</span><br><span class="line">    for (i = 0; i &lt; g.edge; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">        ArcNode * next = new ArcNode;</span><br><span class="line">        next-&gt;tailvex = a - 1; //首先是弧头的下标</span><br><span class="line">        next-&gt; headvex = b - 1; //弧尾的下标</span><br><span class="line">        //只有网图需要权重信息</span><br><span class="line">        if(kind==0)</span><br><span class="line">        next-&gt;weight = -1;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;输入该边的权重：&quot; &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; next-&gt;weight;</span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;tlink = NULL;</span><br><span class="line">        next-&gt;hlink = NULL;</span><br><span class="line">        //该位置的顶点的出度还为空时，直接让你fisrstout指针指向新的表结点</span><br><span class="line">        //记录的出度信息</span><br><span class="line">        if (g.node[a - 1].firstout == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            g.node[a - 1].firstout = next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ArcNode * now;</span><br><span class="line">            now = g.node[a - 1].firstout;</span><br><span class="line">            while (now-&gt;tlink)</span><br><span class="line">            &#123;</span><br><span class="line">                now = now-&gt;tlink;</span><br><span class="line">            &#125;</span><br><span class="line">            now-&gt;tlink = next;</span><br><span class="line">        &#125;</span><br><span class="line">        //记录某个顶点的入度信息</span><br><span class="line">        if (g.node[b - 1].firstin == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            g.node[b - 1].firstin = next;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ArcNode * now;</span><br><span class="line">            now = g.node[b - 1].firstin;</span><br><span class="line">            while (now-&gt;hlink)//找到最后一个表结点</span><br><span class="line">            &#123;</span><br><span class="line">                now = now-&gt;hlink;</span><br><span class="line">            &#125;</span><br><span class="line">            now-&gt;hlink = next;//更新最后一个表结点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(Graph g)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    cout &lt;&lt; &quot;各个顶点的出度信息&quot; &lt;&lt; endl;</span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; g.node[i].data &lt;&lt; &quot; &quot;;</span><br><span class="line">        ArcNode * now;</span><br><span class="line">        now = g.node[i].firstout;</span><br><span class="line">        while (now)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; now-&gt;headvex &lt;&lt; &quot; &quot;;</span><br><span class="line">            now = now-&gt;tlink;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;^&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;各个顶点的入度信息&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; g.node[i].data &lt;&lt; &quot; &quot;;</span><br><span class="line">        ArcNode * now;</span><br><span class="line">        now = g.node[i].firstin;</span><br><span class="line">        while (now)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; now-&gt;tailvex &lt;&lt; &quot; &quot;;</span><br><span class="line">            now = now-&gt;hlink;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;^&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Graph g;</span><br><span class="line">    cout &lt;&lt; &quot;有向图的例子&quot; &lt;&lt; endl;</span><br><span class="line">    createGraph(g, 0);</span><br><span class="line">    print(g);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20170226171617219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="无向图的存储结构—-邻接多重表-1"><a href="#无向图的存储结构—-邻接多重表-1" class="headerlink" title="无向图的存储结构—-邻接多重表"></a>无向图的存储结构—-邻接多重表</h4><p>邻接多重表是无向图的另一种链式存储结构。我们之前也说了使用邻接矩阵来存储图比价浪费空间，但是如果我们使用邻接表来存储图时，对于无向图又有一些不便的地方，例如我们需要对一条已经访问过的边进行删除或者标记等操作时，我们除了需要找到表示同一条边的两个结点。这会给我们的程序执行效率大打折扣，所以这个时候，邻接多重表就派上用场啦。</p>
<p>首先，邻接多重表同样是对邻接表的一个改进得到来的结构，它同样需要一个头结点保存每个顶点的信息和一个表结点，保存每条边的信息，他们的结构如下：<br><img src="https://img-blog.csdn.net/20170227144216870?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>其中，头结点的结构和邻接表一样，而表结点中就改变比较大了，其中mark为标志域，例如标志是否已经访问过，ivex和jvex代表边的两个顶点在顶点表中的下标，ilink指向下一个依附在顶点ivex的边，jlink指向下一个依附在顶点jvex的边，weight在网图的时候使用，代表该边的权重。</p>
<p>下面是一个无向图的邻接多重表的实例（自己也可以尝试去画画，具体的原理都是很简单的）：<br><img src="https://img-blog.csdn.net/20170227151046657?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="无向图的存储结构—-邻接多重表代码实现-1"><a href="#无向图的存储结构—-邻接多重表代码实现-1" class="headerlink" title="无向图的存储结构—-邻接多重表代码实现"></a>无向图的存储结构—-邻接多重表代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//表结点</span><br><span class="line">struct ArcNode</span><br><span class="line">&#123;</span><br><span class="line">    int mark; //标志位</span><br><span class="line">    int ivex; //输入边信息的那个起点</span><br><span class="line">    ArcNode * ilink; //依附在顶点ivex的下一条边的信息</span><br><span class="line">    int jvex;   //输入边信息的那个终点</span><br><span class="line">    ArcNode * jlink; //依附在顶点jvex的下一条边的信息</span><br><span class="line">    int weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//头结点</span><br><span class="line">struct VexNode &#123;</span><br><span class="line">    string data;   //顶点的信息，如顶点名称</span><br><span class="line">    ArcNode * firstedge; //第一条依附顶点的边</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Graph &#123;</span><br><span class="line">    int vexnum;   //顶点的个数</span><br><span class="line">    int edge;    //边的个数</span><br><span class="line">    VexNode *node; //保存顶点信息</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void createGraph(Graph &amp; g)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;请输入顶点的个数：&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; g.vexnum;</span><br><span class="line">    cout &lt;&lt; &quot;请输入边的个数（无向图/网要乘2）：&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; g.edge;</span><br><span class="line">    g.node = new VexNode[g.vexnum];</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line">    cout &lt;&lt; &quot;输入每个顶点的信息：&quot; &lt;&lt; endl;//记录每个顶点的信息</span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; g.node[i].data;</span><br><span class="line">        g.node[i].firstedge = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;请输入每条边的起点和终点的编号：&quot; &lt;&lt; endl;</span><br><span class="line">    for (i = 0; i &lt; g.edge; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">        ArcNode * next = new ArcNode;</span><br><span class="line">        next-&gt;mark = 0;</span><br><span class="line">        next-&gt;ivex = a - 1; //首先是弧头的下标</span><br><span class="line">        next-&gt;jvex = b - 1; //弧尾的下标</span><br><span class="line">        next-&gt;weight = -1;</span><br><span class="line">        next-&gt;ilink = NULL;</span><br><span class="line">        next-&gt;jlink = NULL;</span><br><span class="line"></span><br><span class="line">        //更新顶点表a-1的信息</span><br><span class="line">        if (g.node[a - 1].firstedge == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            g.node[a - 1].firstedge = next;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ArcNode * now;</span><br><span class="line">            now = g.node[a - 1].firstedge;</span><br><span class="line">            while (1) &#123;</span><br><span class="line">                if (now-&gt;ivex == (a - 1) &amp;&amp; now-&gt;ilink == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    now-&gt;ilink = next;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (now-&gt;ivex == (a - 1) &amp;&amp; now-&gt;ilink != NULL) &#123;</span><br><span class="line">                    now = now-&gt;ilink;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (now-&gt;jvex == (a - 1) &amp;&amp; now-&gt;jlink == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    now-&gt;jlink = next;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (now-&gt;jvex == (a - 1) &amp;&amp; now-&gt;jlink != NULL) &#123;</span><br><span class="line">                    now = now-&gt;jlink;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //更新顶点表b-1</span><br><span class="line">        if (g.node[b - 1].firstedge == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            g.node[b - 1].firstedge = next;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            ArcNode * now;</span><br><span class="line">            now = g.node[b - 1].firstedge;</span><br><span class="line">            while (1) &#123;</span><br><span class="line">                if (now-&gt;ivex == (b - 1) &amp;&amp; now-&gt;ilink == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    now-&gt;ilink = next;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (now-&gt;ivex == (b - 1) &amp;&amp; now-&gt;ilink != NULL) &#123;</span><br><span class="line">                    now = now-&gt;ilink;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (now-&gt;jvex == (b - 1) &amp;&amp; now-&gt;jlink == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    now-&gt;jlink = next;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (now-&gt;jvex == (b - 1) &amp;&amp; now-&gt;jlink != NULL) &#123;</span><br><span class="line">                    now = now-&gt;jlink;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(Graph g)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; g.node[i].data &lt;&lt; &quot; &quot;;</span><br><span class="line">        ArcNode * now;</span><br><span class="line">        now = g.node[i].firstedge;</span><br><span class="line">        while (now)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;ivex=&quot; &lt;&lt; now-&gt;ivex &lt;&lt; &quot; jvex=&quot; &lt;&lt; now-&gt;jvex &lt;&lt; &quot; &quot;;</span><br><span class="line">            if (now-&gt;ivex == i)</span><br><span class="line">            &#123;</span><br><span class="line">                now = now-&gt;ilink;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (now-&gt;jvex == i)</span><br><span class="line">            &#123;</span><br><span class="line">                now = now-&gt;jlink;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Graph g;</span><br><span class="line">    createGraph(g);</span><br><span class="line">    print(g);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：<br><img src="https://img-blog.csdn.net/20170227155439125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>来源（<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35644234/article/details/57083107%EF%BC%89">https://blog.csdn.net/qq_35644234/article/details/57083107）</a></p>

      
      
        <div class="page-reward">
          <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang">赏</a></p>
          <div class="hide_box"></div>
          <div class="shang_box">
            <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()">×</a>
            <div class="shang_tit">
              <p></p>
            </div>
            <div class="shang_payimg">
              <img src="/img/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
            </div>
              <div class="pay_explain">扫码打赏</div>
            <div class="shang_payselect">
              
                <div class="pay_item checked" data-id="alipay">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/zfbzf.png" alt="支付宝" /></span>
                </div>
              
              
                <div class="pay_item" data-id="wechat">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/wxzf.png" alt="微信" /></span>
                </div>
              
            </div>
            <div class="shang_info">
              <p>打开<span id="shang_pay_txt">支付宝</span>扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
        <script type="text/javascript">
          $(".pay_item").click(function(){
            $(this).addClass('checked').siblings('.pay_item').removeClass('checked');
            var dataid=$(this).attr('data-id');
            $(".shang_payimg img").attr("src","/img/"+dataid+"img.jpg");
            $("#shang_pay_txt").text(dataid=="alipay"?"支付宝":"微信");
          });
          function dashangToggle(){
            
            $(".hide_box").fadeToggle();
            $(".shang_box").fadeToggle();
          }
        </script>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2021/05/14/%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"></a></p>
        <p><span>文章作者:</span><a href="/" title="访问  的个人博客"></a></p>
        <p><span>发布时间:</span>2021年05月14日 - 23时24分</p>
        <p><span>最后更新:</span>2021年05月14日 - 23时30分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2021/05/14/%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="">https://mingren1314.github.io/2021/05/14/%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a>
            <span class="copy-path" data-clipboard-text="原文: https://mingren1314.github.io/2021/05/14/%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/　　作者: " title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2021/05/14/%E5%88%9D%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2021/05/14/javaweb%E5%9F%BA%E7%A1%80/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title"></div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">进阶数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">树的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">树的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">树的相关定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.1.4.</span> <span class="toc-text">树的表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">二叉树基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">二叉树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">二叉树的特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BD%A2%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">二叉树的形式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A"><span class="toc-number">1.2.4.</span> <span class="toc-text">满二叉树：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A"><span class="toc-number">1.2.5.</span> <span class="toc-text">完全二叉树：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%85%85%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.6.</span> <span class="toc-text">扩充二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.7.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.8.</span> <span class="toc-text">线索二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%9A"><span class="toc-number">1.2.9.</span> <span class="toc-text">二叉树的性质：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.10.</span> <span class="toc-text">存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.10.1.</span> <span class="toc-text">顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.10.2.</span> <span class="toc-text">链式存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BF%E7%9C%9F%E6%8C%87%E9%92%88%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.10.3.</span> <span class="toc-text">仿真指针存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.11.</span> <span class="toc-text">二叉树的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">二叉树的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">前序遍历：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E7%94%BB%E6%A0%91%E5%B9%B6%E6%8E%A8%E5%87%BA%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97"><span class="toc-number">1.3.1.4.1.</span> <span class="toc-text">1.前序中序画树并推出后序序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E7%94%BB%E6%A0%91%E5%B9%B6%E6%8E%A8%E5%87%BA%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97"><span class="toc-number">1.3.1.4.2.</span> <span class="toc-text">2.中序后序画树并推出前序序列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.3.2.</span> <span class="toc-text">二叉树的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">二叉树的遍历(代码实现)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">后序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E7%82%B9%E6%95%B0"><span class="toc-number">1.3.4.</span> <span class="toc-text">二叉树结点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">二叉树子结点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%90%E4%B8%80%E5%B1%82%E7%BB%93%E7%82%B9%E6%95%B0"><span class="toc-number">1.3.6.</span> <span class="toc-text">某一层结点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%9F%90%E4%B8%80%E5%B1%82"><span class="toc-number">1.3.7.</span> <span class="toc-text">输出某一层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.8.</span> <span class="toc-text">层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E6%95%B0"><span class="toc-number">1.3.9.</span> <span class="toc-text">查找某个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.10.</span> <span class="toc-text">销毁二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.11.</span> <span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.</span> <span class="toc-text">树和二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.1.</span> <span class="toc-text">树转二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A0%91"><span class="toc-number">1.4.2.</span> <span class="toc-text">二叉树转树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97"><span class="toc-number">1.5.</span> <span class="toc-text">森林</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">1.5.1.</span> <span class="toc-text">概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">性质:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.</span> <span class="toc-text">森林和二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.1.</span> <span class="toc-text">森林转二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A3%AE%E6%9E%97"><span class="toc-number">1.6.2.</span> <span class="toc-text">二叉树转森林</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.</span> <span class="toc-text">树和森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.1.</span> <span class="toc-text">树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">例子:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.8.</span> <span class="toc-text">哈夫曼树(最优二叉树)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.1.</span> <span class="toc-text">哈夫曼树的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">1.8.2.</span> <span class="toc-text">哈夫曼树的构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.8.3.</span> <span class="toc-text">构建代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">1.8.4.</span> <span class="toc-text">哈夫曼编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.8.5.</span> <span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">1.9.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.9.1.</span> <span class="toc-text">图的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%9A"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">无向图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%9A"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">有向图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%9B%BE%EF%BC%9A"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">完全图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E5%9B%BE%EF%BC%9A"><span class="toc-number">1.9.1.4.</span> <span class="toc-text">稀疏图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%A0%E5%AF%86%E5%9B%BE%EF%BC%9A"><span class="toc-number">1.9.1.5.</span> <span class="toc-text">稠密图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%EF%BC%9A"><span class="toc-number">1.9.1.6.</span> <span class="toc-text">网：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%EF%BC%9A"><span class="toc-number">1.9.1.7.</span> <span class="toc-text">邻接：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%EF%BC%88%E4%BE%9D%E9%99%84%EF%BC%89%EF%BC%9A"><span class="toc-number">1.9.1.8.</span> <span class="toc-text">关联（依附）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9A%84%E5%BA%A6%EF%BC%9A"><span class="toc-number">1.9.1.9.</span> <span class="toc-text">顶点的度：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%EF%BC%9A"><span class="toc-number">1.9.1.10.</span> <span class="toc-text">路径：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%EF%BC%9A"><span class="toc-number">1.9.1.11.</span> <span class="toc-text">路径长度：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B7%AF%EF%BC%88%E7%8E%AF%EF%BC%89%EF%BC%9A"><span class="toc-number">1.9.1.12.</span> <span class="toc-text">回路（环）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%B7%AF%E5%BE%84%EF%BC%9A"><span class="toc-number">1.9.1.13.</span> <span class="toc-text">简单路径：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%9B%BE%EF%BC%88%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE%EF%BC%89%EF%BC%9A"><span class="toc-number">1.9.1.14.</span> <span class="toc-text">连通图（强连通图）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E4%B8%8E%E7%BD%91%EF%BC%9A"><span class="toc-number">1.9.1.15.</span> <span class="toc-text">权与网：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E5%9B%BE%EF%BC%9A"><span class="toc-number">1.9.1.16.</span> <span class="toc-text">子图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%EF%BC%88%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%EF%BC%89%EF%BC%9A"><span class="toc-number">1.9.1.17.</span> <span class="toc-text">连通分量（强连通分量）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%81%E5%B0%8F%E8%BF%9E%E9%80%9A%E5%AD%90%E5%9B%BE%EF%BC%9A"><span class="toc-number">1.9.1.18.</span> <span class="toc-text">极小连通子图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97"><span class="toc-number">1.9.1.19.</span> <span class="toc-text">生成树与森林</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.2.</span> <span class="toc-text">图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">图的存储结构—-邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">图的存储结构—-邻接矩阵的代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">图的存储结构—邻接表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.2.4.</span> <span class="toc-text">图的存储结构—-邻接表的代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.9.2.5.</span> <span class="toc-text">图的存储结构—-邻接表的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-number">1.9.2.6.</span> <span class="toc-text">有向图的存储结构—-十字链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.2.7.</span> <span class="toc-text">有向图的存储结构—-十字链表代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="toc-number">1.9.2.8.</span> <span class="toc-text">无向图的存储结构—-邻接多重表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.2.9.</span> <span class="toc-text">无向图的存储结构—-邻接多重表代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-1"><span class="toc-number">1.9.2.10.</span> <span class="toc-text">图的存储结构—-邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.9.2.11.</span> <span class="toc-text">图的存储结构—-邻接矩阵的代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E9%82%BB%E6%8E%A5%E8%A1%A8-1"><span class="toc-number">1.9.2.12.</span> <span class="toc-text">图的存储结构—邻接表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.9.2.13.</span> <span class="toc-text">图的存储结构—-邻接表的代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">1.9.2.14.</span> <span class="toc-text">图的存储结构—-邻接表的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8-1"><span class="toc-number">1.9.2.15.</span> <span class="toc-text">有向图的存储结构—-十字链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.9.2.16.</span> <span class="toc-text">有向图的存储结构—-十字链表代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8-1"><span class="toc-number">1.9.2.17.</span> <span class="toc-text">无向图的存储结构—-邻接多重表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.9.2.18.</span> <span class="toc-text">无向图的存储结构—-邻接多重表代码实现</span></a></li></ol></li></ol></li></ol></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">


<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'swing'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>
    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2021/05/14/%E5%88%9D%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="上一篇: ">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2021/05/14/javaweb%E5%9F%BA%E7%A1%80/" title="下一篇: ">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E6%98%8E%E6%98%8E%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0/">明明的随机数</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/BF%20KMP/">BF KMP</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E6%8E%92%E5%BA%8F/">排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E6%9E%9A%E4%B8%BE/">枚举</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">动态内存分配</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">自定义数据类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/">进制转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/scanf%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A2%AB%E5%BF%BD%E7%95%A5%E9%97%AE%E9%A2%98/">scanf返回值被忽略问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E6%8C%87%E9%92%88%E9%9D%A2%E8%AF%95%E9%A2%98/">指针面试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E8%BF%9B%E9%98%B6%E6%8C%87%E9%92%88/">进阶指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/">文件操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E5%88%9D%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">初级数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">进阶数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/javaweb%E5%9F%BA%E7%A1%80/">javaweb基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E5%8F%8D%E5%B0%84/">反射</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/14/%E9%9B%86%E5%90%88/">集合</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2021 mingr
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="http://bestwing.me" target="_blank">Sw'blog</a> by Swing
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >海贼到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


    <script type="text/javascript">
      window.onload = function(){
        document.getElementById("search").onclick = function(){
            console.log("search")
            search();
        }
      }
      function search(){
        (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
        (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
        e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
        })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

        _st('install','A1Pz-LKMXbrzcFg2FWi6','2.0.0');
      }
    </script>

  </div>
</body>
</html>